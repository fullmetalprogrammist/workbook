### Задача: система управления библиотечным фондом

**Уровень сложности:** средний‑высокий.

**Цель:** отработать:

- создание и композицию структур;
- методы и приёмники (value/pointer receivers);
- встраивание (embedding);
- теги полей (`json:`, `validate:`);
- сравнение и копирование структур;
- работу с срезами структур и картами;
- «конструкторы» (фабричные функции).

------

### Условия

Разработайте пакет `library`, реализующий базовую систему учёта книг в библиотеке.

#### 1. Основные структуры

Определите следующие типы:

- `Author`
  Поля: `FirstName`, `LastName` (строки).
  Метод: `FullName() string` — возвращает полное имя.
- `ISBN` (тип‑обёртка для строки)
  Метод: `IsValid() bool` — проверяет формат ISBN‑13 (13 цифр, может быть дефисы).
- `Book`
  Поля:
  - `Title string`
  - `ISBN ISBN`
  - `Authors []Author`
  - `Year int`
  - `Genre string`
  - `Available bool`
    Теги: `json:"title"`, `validate:"required"` и т. п.
    Методы:
  - `AddAuthor(a Author)` — добавляет автора (приёмник‑указатель).
  - `String() string` — форматирует книгу как строку.
- `Library`
  Поле: `Books map[ISBN]*Book` (карта для быстрого поиска по ISBN).
  Методы:
  - `AddBook(b *Book) error` — добавляет книгу, проверяет уникальность ISBN.
  - `FindByTitle(title string) []*Book` — ищет книги по названию (частичное совпадение).
  - `Checkout(isbn ISBN) error` — меняет `Available` на `false`, если книга есть и доступна.
  - `Return(isbn ISBN) error` — возвращает книгу (`Available = true`).
  - `Stats() map[string]int` — возвращает статистику: количество книг, доступных, по жанрам и т. п.

#### 2. Дополнительно

- Реализуйте фабричную функцию `NewBook(title string, isbn string) (*Book, error)` — создаёт книгу, проверяет ISBN, инициализирует поля.
- Для `Library` — фабричная функция `NewLibrary() *Library` (инициализирует карту).
- Используйте встраивание, если нужно вынести общую логику (например, валидацию).
- Добавьте юнит‑тесты для ключевых методов (проверка ISBN, добавление/выдача книг, поиск).

#### 3. Пример использования

```
lib := NewLibrary()

book, err := NewBook("The Go Programming Language", "978-0134190440")
if err != nil {
    log.Fatal(err)
}
book.AddAuthor(Author{FirstName: "Alan", LastName: "Donovan"})
book.Year = 2015

lib.AddBook(book)

found := lib.FindByTitle("Go")
for _, b := range found {
    fmt.Println(b)
}

lib.Checkout(book.ISBN)
fmt.Println("Available:", book.Available) // false
```

------

### Что отрабатывается

- **Структуры как типы** — `Author`, `Book`, `Library` являются полноценными типами.
- **Композиция** — `Book` содержит срез `Authors`.
- **Встраивание** — можно вынести общие методы (например, валидацию) в отдельную структуру.
- **Приёмники** — методы с value receiver (`FullName`) и pointer receiver (`AddAuthor`, `Checkout`).
- **Теги полей** — для JSON и валидации.
- **Фабричные функции** — `NewBook`, `NewLibrary` вместо прямого `&Book{}`.
- **Карты и срезы** — хранение книг в `map[ISBN]*Book`, поиск в срезе.
- **Проверка ошибок** — возврат `error` из методов.
- **Юнит‑тестирование** — проверка краевых случаев.

------

### Критерии «идиоматичности»

- Названия типов и методов в `CamelCase`.
- Приёмники согласованы: value receiver для «чтения», pointer receiver для изменения.
- Ошибки возвращаются, а не паникуются.
- Публичные поля/методы с заглавной буквы, приватные — с маленькой.
- Использование фабрик вместо прямого создания структур.
- Чёткое разделение ответственности (например, `Library` не валидирует ISBN — это делает `Book`/`ISBN`).