

# Базовый синтаксис промиса

- [Базовый синтаксис промиса](#базовый-синтаксис-промиса)
- [Реалистичные примеры](реалистичные-примеры)
  - Подключение библиотеки через промис

# Выполнение промиса

- Выполнение - синхронное, обработка результата - асинхронная
  - "Промис - это "обертка для значения, которого еще нет, но появится в будущем""
- Выполнение промиса
  - Конструктор промиса
    - Принимает "**экзекутор**" - колбэк, который мы хотим выполнить в промисе
      - У экзекутора два параметра
        - Это функции
          - Общепринятые названия для них
            - `resolve`
            - `reject`
          - Вызов любой из них приводит к завершению промиса
          - Промис создает эти функции внутри своего конструктора и передает экзекутору, когда вызывает его
    - ⚡ Промис вызывает экзекутор внутри своего конструктора
      - Т.е. создание промиса по сути означает моментальное начало выполнения кода ("синхронное выполение")
        - Поэтому специально запускать промис в работу не надо
  - Промис выполняется единожды
    - Повторно запустить его невозможно

# Завершение промиса

- Завершение промиса
  - Два варианта завершения
    - "Успех"
    - "Провал"
  - Для завершения вызываем resolve *или* reject
    - `resolve(значение)` - для успешного завершения промиса
      - Передаем значение, которое хотим вернуть как итог работы
    - `reject(error)` - для отклонения промиса, "неуспешное" завершение
      - Передаем причину неуспешного завершения
        - Обычно это объект ошибки
  - Вызов resolve \ reject сам по себе не делает выход из экзекутора
    - Но лучше строить код так, чтобы экзекутор заканчивался этими вызовами, чтобы не было путаницы
      - Именно "прервать" экзекутор можно вызовом return

# Статусы промиса

- Статусы промиса
  - Всего 3 возможных статуса
    - `pending` - начальный статус. Будет до тех пор, пока не вызваны resolve \ reject
    - `fullfilled` - статус после вызова resolve (промис завершен успешно)
    - `rejected` - статус после вызова reject (промис "отклонен")
  - Статус хранится в системном поле промиса `[[PromiseState]]`
    - Явно прочитать его нельзя
    - Изменить вручную нельзя
    - Это внутренняя механика промиса, с ним непосредственно работают только собственные методы промиса

# Результат промиса

- Результат промиса
  - ⚡ Технически, и "значение" переданное в resolve, и "ошибка" переданная в reject, являются *результатом*
    - Т.е. деление на логическое, технически это хранится одинаково
      - Результат хранится в системном поле `[[PromiseResult]]`
        - Получить доступ к результату напрямую из объекта промиса - нельзя
  - [Получение результата из промиса](получение-результата-из-промиса)
    - Нужны методы промиса `then` \ `catch`
      - Они принимают колбэки ("**подписчиков**")
        - Подписчики хранятся в системных полях промиса
          - `[[PromiseFulfillReactions]]` - подписчики на успешное завершение промиса
          - `[[PromiseRejectReactions]]` - подписчики на отклонение промиса
      - Подписчики автоматически вызываются после завершения промиса
        - У функции-подписчика единственный параметр - через него он получает результат
      - `.then(onFullfilled, onRejected)`
        - onFullfilled - подписчик на успешное завершение
          - `result => console.log('Результат работы промиса: ' + result)`
        - onRejected - подписчик на отклонение
          - `error => console.log('Промис отклонен с ошибкой: ' + error.message)`
      - `.catch(onRejected)`
        - onRejected - подписчик на отклонение
          - `error => console.log('Промис отклонен с ошибкой: ' + error.message)`
        - catch(onRejected) это аналог then(null, onRejected), созданный для удобства

# Освобождение ресурсов

- [Освобождение ресурсов](освобождение-ресурсов)
  - Метод `finally(onFulfilledAndRejected)`
    - Подписчик, добавленный через finally, результат \ ошибку не получает
      - Он выполняется при любом завершении промиса, что при резолве, что при отклонении
        - Нужен для выполнения "очистки", "освобождения ресурсов"
          - Закрытие файлов, сетевых соединений и т.д.
      - `() => console.log('Освобождаем ресурсы')`

# Цепочки методов then \ catch \ finally

- [Цепочки методов then \ catch \ finally](цепочки-then-catch-finally)
  - Методы then \ catch \ finally возвращают новый промис (**"Y"**)
    - Поэтому эти методы можно писать цепочками
      - `prom.then(s).then(s).catch(s).finally(s)` - это цепочка
    - Поэтому технически, finally не обязательно писать в самом конце
      - `.then(s).finally(s).then(s)` - технически это корректно
  - Подписчик выполняется, когда промис, на который его повесили, завершается
    - Подписчик выполняется в новой микрозадаче
    - Подписчик выполнился > Y-промис зарезолвился > Этот факт тригернул выполнение следующего подписчика > И так до конца цепочки
- Если вызывать несколько раз метод на исходном промисе - это *не* цепочка
  - `prom.then(s); prom.then(s); prom.then(s)` - не цепочка
  - В этом случае все подписчики добавляются в очередь исходного промиса
    - И выполняются в ОДНОЙ микрозадаче согласно порядку добавления в очередь

# Ошибки в промисах

- [Ошибки в промисах](ошибки-в-промисах)
  - Не пойманные
    - Синхронные
      - Непойманная ошибка в колбэке - это все равно что отклонить промис с этой ошибкой
    - Асинхронные
      - Если ошибка возникает асинхронно, например, в колбэке поставили setTimeout и внутри него ошибка, промис эту ошибку поймать "автоматически" не может
        - Чтобы отклонить промис в таком случае, надо явно поймать ошибку через try-catch и сделать reject
  - Прочие кейсы
    - Необработанные отклоненные промисы
      - Не кладут программу (пока что, потом это поведение могут изменить)
      - TODO дописать \ доразобраться

# Механика промисов

- [Механика промисов](механика-промисов)
- Промисы и микрозадачи
- TODO

# API промисов

- [API промисов](api-промисов)
  - Это вспомогательные функции для удобства работы с промисами
    - В основном для случаев, когда надо выполнить много промисов по определенной логике
  - Реализованы как static методы класса Promise
    - Например, `Promise.all(iterable)`
    - Возвращают новый промис
- Методы
  - Для обработки пачки промисов
    - Принимают iterable (обычно массив) промисов
      - Если передать не промис, а обычное значение, оно автоматически обернется в успешный промис
    - Возвращают промис, который резолвится \ отклоняется в зависимости от концепции метода
    - Концепции
      - Если все успешные, берем всех, либо первого отклоненного
        - [.all(iterable)](api-промисов#all)
      - Берем всех, неважно успешные или нет
        - [.allSettled(iterable)](api-промисов#allsettled)
      - Берем самого быстрого, хоть успешного, хоть нет
        - [.race(iterable)](api-промисов#race)
      - Берем первого успешного
        - [.any(iterable)](api-промисов#any)
  - [Соло промисы](api-промисов#resolve-и-reject)
    - `.resolve(значение)` - возвращает завершенный успешно промис
    - `.reject(error)` - возвращает отклоненный промис



















