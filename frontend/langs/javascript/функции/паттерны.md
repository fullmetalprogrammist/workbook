# Именованные параметры

- что такое
  - именованные параметры - это способ при передаче значений в функцию указать имя параметра, для которого это значение предназначено
    - например, `db.Connect(server: "sql-server-01", protocol: "SSL", timeout: 120);`
  - полезно, когда параметров много, у них есть значения по умолчанию, а вызывать функцию хочется с разными комбинациями
    - в этом случае позиционные параметры не удобные
      - потому что невозможно скипнуть какой-то параметр из середины, надо передавать все
- в JS именованных параметров нет
  - но можно их имитировать
    - вместо отдельных параметров функция должна принимать объект + делать его деструктуризацию

```javascript
function connect({ server, port = 1433, encrypt = true, timeout = 30, protocol = "TCP" }) {
    console.log(`Connecting to ${server}:${port}`);
    console.log(`Encryption: ${encrypt}, Timeout: ${timeout}s`);
    console.log(`Protocol: ${protocol}, Connection pooling: ${poolConnections}`);
}

// Вызов, порядок не важен. port скипнули, protocol и encrypt указали в произвольном порядке
connect({ server: "localhost", protocol: "SSL", encrypt: false });
```



# IIFE

- Immediately Invoked Function Expression
- суть
  - функция объявляется, тут же вызывается и более не существует, как бы одноразовая

```javascript
(function() {  // <-- В блоке объявляется функция
  console.log('Паттерн IIFE');
})();  // <-- И тут же вызывается
```

- когда полезно
  - идеальный пример в react, когда надо в useEffect сделать асинхронный вызов
    - через IIFE можно разом и объявить, и вызвать функцию, без необходимости сохранять ее в переменную

```jsx
import React, { useState, useEffect } from 'react';

const SimpleComponent = () => {
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);

  useEffect(() => {
    (async () => {  // <-- Удобно через IIFE
      try {
        const response = await fetch('/api/users');
        const result = await response.json();
        setData(result);
      } catch (error) {
        setError(error.message);
      }
    })();
  }, []);

  if (error) return <p style={{color: 'red'}}>Error: {error}</p>

  return <p>{data ? JSON.stringify(data) : 'Loading...'}</p>
};

export default SimpleComponent;
```

Без IIFE:

```jsx
useEffect(() => {
  const fetchData = async () => {  // <-- Функция в отдельной переменной
    // логика
  };
  fetchData();  // <-- Вызов
}, []);
```





# Декорирование функций

- декорирование функции
  - это когда мы передаем исходную функцию в другую функцию, а она нам возвращает третью функцию, которая вызывает исходную + делает какие-то дополнительные действия
    - например
      - исходная функция вычисляет число pi до указанного количества знаков
      - функция-декоратор должна кэшировать вычисленные значения и если запрашивается "вычисли до 10 знаков", и до 10 знаков уже вычислялось раньше, то значение просто возвращается из кэша

```javascript
function doubled(value) {  // <-- Исходная функция
  console.log("Для получения результата вызван метод doubled.");
  return value * value;
}

function cache(func) {  // <-- Фабричная функция - создает декоратор
  let storage = new Map();

  return function(value) {  // <-- Функция-декоратор
    if (storage.has(value)) {
      return storage.get(value);
    }
    
    let result = func(value);
    storage.set(value, result);

    return result;
  }
}

doubled = cache(doubled);  // <-- Можно перезасать оригинальную функцию
// cachedDoubled = cache(doubled);  // <-- Или сохранить кэширующую версию отдельно

console.log(doubled(4));
console.log(doubled(5));
console.log(doubled(4));
```

- тот же пример, но с объектами
  - суть в том, чтобы понять как не потерять this

```javascript
"use strict";

let actions = {
  doubledCalc(value) {
    return value * value;
  },

  doubled(value) {
    console.log("Для получения результата вызван метод doubled.");
    return this.doubledCalc(value);  // <-- Важно не потерять this при кэшировании
  }
};

function cache(func) {
  let storage = new Map();

  return function(value) {
    if (storage.has(value)) {
      return storage.get(value);
    }
    
    let result = func.call(this, value);
    storage.set(value, result);

    return result;
  }
}

actions.doubled = cache(actions.doubled);

console.log(actions.doubled(4));
console.log(actions.doubled(5));
console.log(actions.doubled(4));
```

- как работает
  - в декорируемой функции doubled есть this и надо кэшировать ее так, чтобы этот this имел при вызове правильное значение - объект с методом doubledCalc, который делает работу
  - благодаря вызову через func.call в декораторе мы передаем this в функцию явно
  - кэшированную версию мы кладем в объект вместо оригинальной функции
  - за счет вызова кэшированной функции как метода на объекте, this в ней указывает на этот объект
    - т.к. объект тот что нужен, то кэшированная функция правильно вызывает doubledCalc, который делает вычисления