# Function Declaration

```javascript
function hello(firstname, lastname) {
  let message = `Hello, ${firstname} ${lastname}!`;
  return message;
}  // <-- Не нужна точка с запятой
```



# Function Expression

## Безымянная FE

```javascript
let hello = function(name, age = 25) {
  console.log(`Пользователю ${name} сейчас ${age} лет.`);
};  // <-- Нужна точка с запятой

hello();
```

## Именованная FE - NFE

```javascript
let hello = function foobar(name) {  // <-- Даем функции имя foobar
  if (name) {
    console.log("Hello, " + name);
  } 
  else {
    foobar("stranger");  // <-- Обращаемся к самой себе по имени
  }
};

hello("Tom");  // Hello, Tom
hello();  // Hello, stranger

foobar("Huck");  // ❌ foobar is not defined 
```

## Зачем существуют FE

- зачем существуют
  - появились в 1995 году, их использовали вместо лямбд, которые появились только в 2015
    - передача колбэков в map, reduce, вот это вот все делалось через FE до лямбд
  - после появления лямбд как будто не особо нужны, можно считать за legacy
- чем все же могут быть полезны
  - паттерн IIFE
  - дебаг в асинхронных операциях - имя функции поможет ориентироваться

```javascript
someAsyncOp().then(function processResult(data) { 
  // В стектрейсе будет "processResult"
});
```



# Лямбды

## Варианты синтаксиса

* Несколько параметров:

  ```javascript
  let sum = (a, b) => a + b;
  ```

* Один параметр:

  ```javascript
  let sqr = a => a * a;
  ```

* Нет параметров:

  ```javascript
  let sqr = () => alert("Лямбда без параметров.");
  ```

* Тело из нескольких строк:

  ```javascript
  let sum = (a, b) => {
    let result = a + b;
    return result;
  };
  ```





# Функции-конструкторы

```javascript
function User(name) {  // <-- При вызове функции через new
  // this = {};        // <-- неявно создается новый пустой объект и помещается в this
  this.name = name;    // <-- Теперь в этот объект мы можем накидать свойств (и методов)
  // return this;      // <-- А в конце функции этот this неявно автоматически возвращается
};

let tom = new User("Tom");  // <-- Используем new для вызова ФК, чтобы заработала "магия"
let huck = new User("Huck");
```



# Колбэки

```javascript
function question(text, yes, no) {
  if (confirm(text)) yes()  // Некий код сам вызывает функции yes и no, которые мы ему передали
  else no();
}

// Коллбэки: мы описали функции и сохранили их в переменные
let yesAction = function() { alert("Вы согласились."); }
let noAction = function() { alert("Вы отклонили предложение."); }

question("Вы согласны, что Земля круглая?", yesAction, noAction);  // Передаем колбэки
```

Или так, без промежуточных переменных:

```javascript
question(
  "Вы согласны, что Земля круглая?", 
  function() { alert("Вы согласились."); }, 
  function() { alert("Вы отклонили предложение."); }
);
```







# arguments

```javascript
foo("Huck", "Finn");  // <-- Значения попадут в arguments[0] и arguments[1] соответственно

function foo(name, surname) {  
  console.log(Array.isArray(arguments));  // false, т.е. это псевдомассив
  console.log(arguments[0]);  // Huck
  console.log(arguments[1]);  // Finn
}
```

Если в функции не описано ни одного параметра, аргументы все равно попадают в arguments:

```javascript
function bar() {  // <-- Параметров нет, но аргументы все равно принимаются
  console.log(arguments[0]);  // Huck
  console.log(arguments[1]);  // Finn
}

bar("Huck", "Finn");
```

- лямбды используют переменную arguments из внешней функции ("своей" такой перменной у лямбды нет):

```javascript
function foo() {
  let showArg = () => console.log(arguments[0]);
  showArg(10);  // 5, а не 10
}

foo(5);
```

