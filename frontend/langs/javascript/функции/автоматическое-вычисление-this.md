# Автоматическое вычисление this

## this в top-level скрипта

```javascript
"use strict";
console.log(this.innerWidth);  // 768
```

```javascript
console.log(this.innerWidth);  // 768
```

## this при вызове обычной функции

```javascript
function foobar() {
  console.log(this.innerWidth);
}

foobar();  // 990 (текущая ширина вьюпорта)
```

В браузере этот код вернет текущую ширину вьюпорта (окна браузера), потому что this установится на объект window.

Со вложенными функциями то же самое, this будет undefined или указывает на глобальный объект:

```javascript
function outer() {
  
  function inner() {
    console.log(this);
  }

  console.log(this);
  inner();  // Window
}

outer();  // Window
```

## this при вызове функции как метода объекта

```javascript
let user = {
  name: "Tom",
  hello() {
    console.log(`Hello, my name is ${this.name}.`);
  }
}

user.hello();  // Hello, my name is Tom
```

## this при вызове функции через new

- когда функция вызывается с использованием ключевого слова new (т.н. "функция-конструктор"), то в начале этой функции неявно создается новый объект
  - this указывает на него, а в конце функции он возвращается

```javascript
function User(name) {
  // this = {};  // Неявно
  this.name = name;
  // return this;  // Неявно
}

let user = new User("Tom");
console.log(user.name);
```

## this в лямбдах

Чтобы понять, какой this будет в лямбде, надо понять, какой он будет во внешнем блоке в *момент создания лямбды*.

Несколько примеров для наглядности:

### Пример 1

```javascript
function Foobar(func) {  // <-- Функция-конструктор
  // this = {};
  this.innerWidth = "Ширина";
  func();
  // return this;
}

let f = () => {
  console.log(this.innerWidth);
  // Несмотря на тело лямбды из одной строки, фигурные скобки
  // здесь использованы специально для наглядности, чтобы визуально
  // обозначить вложенность блока лямбды в блок скрипта.
};

Foobar(f);  // <-- Что здесь выведется в консоль?
```

Здесь *момент создания лямбды* - это момент, когда выполнение скрипта доходит до строки `let f = () => console.log(this.innerWidth);`. *Момент выполнения лямбды* - когда выполняется функция Foobar и выполнение скрипта доходит до строки `func();`. Внешний блок в момент создания лямбды - это скрипт. В скрипте this указывает на глобальный объект, window. Стало быть, когда выполняется лямбда, this указывает на window и в консоль выводится цифра - текущая ширина вьюпорта, например 768, а не слово "Ширина".

### Примеры 2 и 3

```javascript
function foobar() {
  return () => {
    console.log(this.innerWidth);
  };
}
```

В этих примерах интерес будет в том, что *лямбда **создается** внутри функции*, стало быть внешним блоком для лямбды является функция foobar. Поскольку функцию можно вызвать по-разному - как обычную функцию и как метод - то от способа ее вызова будет зависеть значение this внутри нее, а значит лямбду это коснется напрямую.

**Ситуация 1**:

```javascript
function foobar() {
  return () => {
    console.log(this.innerWidth);
  };
}

let f = foobar();
f();  // <-- Что здесь выведется в консоль?
```

foobar вызывается как обычная функция, значит this в ней указывает на глобальный объект, window. Поскольку лямбда создается во время выполнения foobar, то получает значение this такое же, какое оно в foobar. Поэтому в консоль лямбда выводит текущее значение свойства innerWidth объекта window, например, 768.

**Ситуация 2**:

```javascript
function foobar() {
  return () => {
    console.log(this.innerWidth);
  };
}

let win = {
  innerWidth: "Ширина"
};

win.foobar = foobar;  // <-- Добавляем в объект win метод foobar

let f = win.foobar();
f();  // <-- Что здесь выведется в консоль?
```

Здесь мы создаем объект `win` с таким же свойством, какое есть у глобального объекта window, innerWidth. Потом добавляем в объект win функцию foobar в качестве метода и вызываем этот метод, чтобы создать лямбду и положить ее в переменную f. При выполнении метода foobar, this в нем указывает на win, стало быть и в созданной лямбде this будет указывать на win. Поэтому когда мы выполняем лямбду, в консоль выводится слово "Ширина", а не цифра с шириной вьюпорта.