# Оператор ...

Движок может интерпретировать оператор "три точки" `...` двумя способами:

- `spread` - это "разбить". Как взять массив или объект и разбить его об пол на отдельные фрагменты.
- `rest` - это "собрать". Как взять отдельные элементы и собрать их в единый контейнер.

# ... как spread

В местах, где надо *передать* отдельные значения, `...` это spread. Спредом мы разбиваем контейнер на эти самые отдельные значения и они уходят в цель.

Например, при создании массива мы должны указать элементы. Так что мы можем взять уже существующий массив, разбить его на элементы и отдать их в новый массив:

```javascript
const source = [5, 4, 7, 8, 3, 2];  // <-- Какой-то контейнер с элементами
const dest = [...source];  // <-- Тут ожидаются отдельные элементы, "спредим" контейнер

console.log(dest);  // [5, 4, 7, 8, 3, 2]
```

Или при создании объекта мы должны указать свойства. Так что мы можем взять уже существующий объект, разбить его на отдельные свойства и отдать их в новый объект:

```javascript
const source = {
  firstname: "Tom",
  lastname: "Sawyer"
}
const dest = { 
  ...source  // <-- Разбиваем исходный объект на отдельные поля
};

console.log(dest);  // { firstname: 'Tom', lastname: 'Sawyer' }
```

## К чему можно применить spread

spread позволяет:

* Разбить любой *итерируемый* объект (например, массив, map, set, строка и т.д.) на отдельные значения.
  * P.S. Хотя строка - это примитив, но по спецификации языка она является итерируемой, поэтому spread с ней работает.

* Разбить обычный объект на отдельные поля.

# ... как rest

В местах, где значения надо *принять*, `...` работает как rest.

`rest` - это "сбор остатков". Он всегда используется в конце списка параметров \ переменных.

Например, параметры функции - это место, где значения *принимаются* ("приходят"). В функцию приходят отдельные аргументы. Каждый агрумент сопоставляется с параметром. Все аргументы, которым "не хватило" параметров, с помощью rest-оператора можно собрать в единый массив:

```javascript
function hello(firstname, lastname, ...rest) {
  console.log("Имя: " + firstname + " " + lastname);
  console.log("Прозвища:");
  rest.forEach(v => console.log(v));
}
// firstname, lastname |      попадут в массив rest
hello("Джеки", "Чан",    "Громобой", "Азиатский ястреб", "Ковбой", "Тайфун");

// Имя: Джеки Чан
// Прозвища:
//    Громобой
//    Азиатский ястреб
//    Ковбой
//    Тайфун
```

При деструктурирующем присваивании по сути элементы контейнера тоже сопоставляются с переменными. Все элементы, которым "не хватило" переменных, тоже можно собрать в единый массив:

```javascript
let fruits = ["Яблоко", "Груша", "Апельсин", "Мандарин"];
let [apple, pear, ...other] = fruits;

other.forEach(f => console.log(f));  // Апельсин, Мандарин
```

В обоих примерах один принцип - все значения, для которых не хватило параметров \ переменных собираются в `массив` (настоящий массив, а не псевдомассив).

Аналогично для объектов - при деструктуризации мы можем извлечь поля, которые нам нужны, а остальные опять собрать в новый объект:

```javascript
let user = {
  name: "Huck",
  age: 15,
  state: "Illinois"
};

let {state, ...other} = user;  // name и age станут свойствами объекта other

console.log(state);  // Illinois
console.log(other.name);  // Huck
console.log(other.age);   // 15
```



# Типичные сценарии использования

## rest

### Произвольное количество параметров

Например, хотим сделать функцию сложения произвольного количества чисел:

```javascript
function sum(...numbers) {
  return numbers.reduce((acc, cur) => acc += cur, 0);
}

console.log(sum(1, 3));  // 4
console.log(sum(1, 3, 8, 14, 7, 5));  // 38
```

Для лямб аналогично:

```javascript
const sum = (...nums) => nums.reduce((prev, curr) => prev += curr, 0);
console.log(sum(5, 6, 4));  // 15
```

Или хотим принять сообщение и произвольное количество тегов для этого сообщения:

```javascript
function processMessage(message, ...tags) {
  // Что-то делаем с сообщением и тегами.
}
```

### Обертки над функциями

Например, надо сделать обертку для функции и эта обертка должна уметь принять все те же аргументы, что и оригинальная функция:

```javascript
function foobar(foo, bar) {
  const message = foo + " " + bar;
  return message;
}

function wrap(fn) {
  return function(...args) {  // <-- rest
    console.log("Какая-то добавленная функциональность.");
    return fn.apply(this, args);
  }
}

console.log(foobar("Hello", "world"));
const wrapped = wrap(foobar);
console.log(wrapped("Hello", "world"));
```

Обертка, логирующая вызовы функции и ее аргументы:

```javascript
const withLogging = (fn) => (...args) => {
  console.log(`Вызвана ${fn.name} с аргументами:`, args);
  return fn(...args);
};
```

## spread

### Скопировать массив \ объект

Можно скопировать массив, создав т.о. новый массив (копирование не глубокое, скопируется только один уровень):

```javascript
let nums = [5, 10, 3, 15];
let copy = [...nums];
```

Или скопировать объект (аналогично, копирование не глубокое):

```javascript
let tom = { firstname: "Tom", lastname: "Sawyer" };
let clone = { ...tom };
```

### Объединить массивы \ свойства объектов

Можно объединить несколько массивов \ итерируемых объектов:

```javascript
let nums = [5, 10, 3, 15];
let snums = new Set([10, 20, 15, 7]);
let merged = [...nums, ...snums];  // [5, 10, 3, 15, 10, 20, 15, 7]
```

Применяя этот оператор, мы можем представлять себе, что просто пишем отдельные элементы.

Можно объединить несколько объектов в один, слив их свойства:

```javascript
const baseInfo = {
  name: "Tom",
  age: 30
}

const extInfo = {
  city: "New York"
}

const info = { ...baseInfo, ...extInfo }

console.log(info);  // {name: 'Tom', age: 30, city: 'New York'}
```

Одинаковые свойства при этом перекрываются. Чье свойство указано последним, то и попадет в финальный объект. Это можно использовать, чтобы заменять некоторые свойства в объекте, не трогая другие и при этом получая новый объект. Полезно, когда нужна иммутабельность исходных объектов.

# Пример из React

Пример на использование в одном компоненте и оператора "остаточные параметры" и "оператора разбиения":

```react
const MyButton = ({children, ...props}) => {  // <-- rest
  return (
    <button {...props}>{children}</button>  // <-- spread
  );
};
```

В компонент MyButton передается единый объект, в котором среди прочих есть свойство children. С помощью деструктуризации мы извлекаем это свойство в отдельную переменную children, а все остальные свойства с помощью оператора "остаточные параметры" опять собираем в новый объект props.

А вот в компоненте button дальше мы уже пользуемся "оператором разбиения", который разбивает объект props на отдельные переменные и они уходят в компонент как отдельные атрибуты.

Если в компонент MyButton приходит объект props `{children: ololo, disabled: true, visible: true}`, то запись `{children, ...props}` выдерет children в отдельную переменную, а все остальное (в данном случае свойства disabled и visible) соберет в объект props. Далее, `{...props}` разобьет объект props на отдельные переменные и они уйдут в button отдельными атрибутами, все равно что написать `<button disabled=true visible=true>{children}</button>`.

