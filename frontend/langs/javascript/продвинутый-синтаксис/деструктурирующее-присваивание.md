# Карта

## Деструктурирующее присваивание

- или просто "деструктуризация" для краткости
  - это один из способов извлечь данные из массивов, объектов, мап, сетов, строк
- деструктуризацию можно применить к
  - объекту
  - любому iterable-контейнеру
- с оригинальным "контейнером" \ объектом ничего не происходит
  - слово "деструктуризация" не подразумевает какой-то "распад" источника

## Базовый синтаксис

- iterable (массивы, мапы, сеты, строки) - через `[ ]`
  - `let [item1, item2] = container;`
- объекты - через `{ }`
  - `let { name, age } = person;`
- как запомнить синтаксис?
  - массивы создаются с помощью `[ ]`
    - и дестрачатся тоже квадратными скобками
  - объекты создаются с помощью `{ }`
    - и дестрачатся тоже фигурными скобками
- дополнительно
  - то, что слева от `=` называется "шаблон деструктуризации"
  - если в iterable не хватает элементов, чтобы заполнить переменные, то переменные будут undefined
    - аналогично, если в объекте не будет указанных свойств, то переменные тоже будут undefined

## Дополнительные возможности

- [пропуск элементов](#пропуск-элементов)
  - для iterable
  - для объектов
- [деструктуризация в заранее объявленные переменные](#деструктуризация-в-заранее-объявленные-переменные)
  - для iterable
  - для объектов
- [сбор остатков в кучу](#сбор-остатков-в-кучу)
  - с помощью rest-оператора
    - для iterable
    - для объектов
- [значения по умолчанию](#значения-по-умолчанию) для переменных при деструктуризации
  - для iterable
  - для объектов
    - особенно полезно в сложных объектах, чтобы не получать ошибки из-за `undefined.foobar`
- фишки для объектов
  - [сопоставление свойств и переменных](#сопоставление-свойств-и-переменных) при деструктуризации
    - автоматическое
      - если называть переменные так же как свойства в объекте
    - явное
      - нужно когда хочется назвать переменную по-другому
  - [вложенная деструктуризация](#вложенная-деструктуризация)

## Трюки, прочие полезные примеры

- [Свап значений](#свап-значений)

  - переменных
  - полей объекта

- [Перебор свойств объекта](#перебор-свойств-объекта)

- [Перебор элементов мапы](#перебор-элементов-мапы)

- [Деструктуризация api-ответов](#деструктуризация-api-ответов) со сложной структурой

- [Дефолты для полей объекта](#дефолты-для-полей-объекта)

  





# Конспект

## Пропуск элементов

### iterable

- Просто вместо имени переменной не пишем ничего, оставляем голую запятую
- Пропуск элементов обычно полезен, когда в массиве лежат какие-то форматированные данные, например дата, разбитая на год, месяц, день и часть этих данных не нужна:

```javascript
const [, month, day] = "2025-04-28".split("-");
console.log(month);  // 04
console.log(day);    // 28
```

### объекты

- Просто указываем только те поля, которые нужны
- Практическая польза деструктуризации объекта в том, что не надо каждый раз обращаться к полям через точку:

```jsx
const formData = {
  username: 'john_doe',
  email: 'john@test.com',
  _token: 'abc123',
  _timestamp: 1620000000,
  _formId: 'registration'
};

const { username, email } = formData;  // <-- Извлекли "полезные" данные
console.log(username);  // <-- удобнее, чем formData.username
console.log(email);
```



## Деструктуризация в заранее объявленные переменные

### iterable

- просто переменные объявляются заранее, без нюансов

```javascript
let year, month, day;
[year, month, day] = "2025-04-28".split("-");
```

### объекты

- всю конструкцию деструктуризации надо брать в круглые скобки
  - иначе js принимает `{ }` за блок кода и получается ошибка

```javascript
const formData = {
  username: 'john_doe',
  email: 'john@test.com',
  _token: 'abc123',
  _timestamp: 1620000000,
  _formId: 'registration'
};

let username, email;
({ username, email } = formData);

console.log(username);
console.log(email);
```



## Сбор остатков в кучу

### iterable

- если какую-то часть данных при деструктуризации хочется собрать в единую группу, можно сделать это rest-оператором
  - данные соберутся в массив
- например, имя и адрес покупателя извлекаем в отдельные переменные, а заказанные товары объединяем в массив:

```javascript
const order = ["Иван Козлов", "ул. Революции 1", "iPhone", "AirPods", "Чехол", "Защитное стекло"];

let [customer, address, ...products] = order;
console.log(Array.isArray(products));   // true
```

### объекты

- часть свойств при деструктуризации объекта можно собрать в отдельный *объект*
- это часто бывает полезно в реакте
  - компонент деструктурирует пропсы, себе берет только нужные, а остальные собирает в объект и передает дальше

```jsx
function CustomButton({ primary, size, children, ...otherProps }) {
  // Для себя нужны primary, size, children
  // Остальные, сколько бы их ни было, - соберем в otherProps и прокинем дальше
  return (
    <button 
      className={`btn ${primary ? 'btn-primary' : ''} ${size}`}
      {...otherProps}
    >
      {children}
    </button>
  );
}

// Использование
<CustomButton primary size="large" onClick={handleClick} disabled={true}>
  Купить
</CustomButton>
```



## Значения по умолчанию

### iterable

```javascript
const userInfo = [];
const [firstname = "John", lastname = "Doe"] = userInfo;

console.log(`${firstname} ${lastname}`);  // "John Doe"
```

### объекты

- простые объекты

```javascript
const userInfo = {
  firstname: "Mike",
  lastname: "Hunt"
};

const { 
  firstname = "John",  // <-- При объявлении переменных, куда деструктурировать,
  lastname = "Doe",    // указываем значения по умолчанию
  role = "guest" 
} = userInfo;
console.log(`user: ${firstname} ${lastname}, role: ${role}`);  // "user: Mike Hunt, role: guest"
```

- сложные объекты
  - имеются ввиду объекты, поля которых являются массивами, объектами
  - в примере используется вложенная деструктуризация
  - фишка в том, что если не передать size и info и при этом у них не будет значения по умолчанию (`[ ]` и `{ }`), тогда при попытке их деструктурировать будет ошибка

```javascript
let settings = {  // <-- Сложный объект
  title: "Умные параметры",
  size: [400, 200],  // <-- У него поле является массивом
  info: {            // <-- И объектом
    year: 2007,
    duration: 93
  },
  items: ["Привет", "мир"]
};

// <-- Все поля заполнятся из-за деструктуризации объекта settings, поэтому ошибок не будет
foobar(settings);  

// <-- Все поля заполнятся за счет значений по умолчанию, поэтому тоже не будет ошибок
foobar();

function foobar({
  title = "Заголовок",
  size: [width = 300, height = 200] = [],  // <-- Задаем [] по умолч
  info: { year = null, duration = null } = {},  // <-- Задаем {} по умолч
  items = []
} = {}) {
  console.log(title);
  console.log(width + " " + height);
  console.log(year);
  console.log(duration);
  
  for (let item of items) {
    console.log(item);
  }
}
```



## Сопоставление свойств и переменных

### Автоматическое

```javascript
let user = {
  name: "Tom",
  age: 14,
  state: "Missouri"
};

let {state, age, name} = user;  // Порядок не важен, главное совпадение имен

console.log(name);   // Tom
console.log(age);    // 14
console.log(state);  // Missouri
```

### Явное сопоставление переменных и свойств

- формат `{ свойство: переменная }` ("откуда" : "куда")
  - позволяет извлечь указанное свойство в переменную с произвольным именем
- можно комбинировать со значениями по умолчанию

```javascript
let user = {
  name: "Huck",
  age: 15,
  state: "Illinois"
};

let {
  state: s,  // <-- Явное, св-во state -> в переменную s
  age: a,    // <-- Явное, св-во age -> в переменную a
  name,      // <-- Автоматическое сопоставление
  address: adr = "homeless"  // <-- Явное сопоставление + Значение по умолчанию
} = user;

console.log(name);  // Huck
console.log(a);     // 15
console.log(s);     // Illinois
console.log(adr);   // homeless
```



## Вложенная деструктуризация

- когда поле является сложным объектом, который тоже можно деструктурировать, то можно применить к нему повторно синтаксис деструктуризации
  - формат `сложноеПоле: [ ] или { }`

```javascript
let settings = {  // <-- Сложный объект, который надо разбить на переменные
  size: [1920, 1080],
  title: "Мост в Терабитию",
  info: {
    year: 2007,
    duration: 93,
    country: "США"
  }
};

let {  // <-- Начинаем деструктуризацию
  size: [x, y],  // <-- size указывает поле разбиваемого объекта, а x, y - переменные под значения
  title,   // <-- автоматическое сопоставление переменной с полем по имени
  info: {  // <-- info указывает поле разбиваемого объекта
    year: g,  // <-- Поле year из этого объекта положим в переменную g
    duration: d,
    country  // <-- Поле country автосопоставится в переменную country
  }
} = settings;

console.log(x);  // 1920, данные лежат в x, а не size.x
console.log(y);  // 1080
console.log(title);  // Мост в Терабитию
console.log(g);  // 2007
console.log(d);  // 93
console.log(country);  // США
```

> Старое описание:
>
> Принцип такой:
>
> - Если мы хотим получить значение из поля как есть, то просто указываем это поле в деструктуризации. Например, если это примитив, его уже дальше не разобьешь.
> - Если в поле лежит объект и мы хотим его дальше разбить, мы и к нему применяем синтаксис деструктуризации.
>
> Так что деструктуризация называется вложенной, потому что внутри `{ }` есть опять `{ }`.
>
> В примере выше, свойство title - примитив, так что его значение извлекаем на первом уровне деструктуризации. А вот info - это составной объект. Поэтому для него снова применяем синтаксис деструктуризации. size - тоже не примитив, а массив, поэтому и для него можем применить деструктуризацию.
>
> При вложенной деструктуризации также работает правило автосопоставления свойств и переменных. Как в случае со свойством country.

# Трюки, прочие полезные примеры

## Свап значений

### Переменных

```javascript
let name = "John Doe";
let age = 40;

[name, age] = [age, name];
console.log(name);  // 40
console.log(age);   // John
```

- работает за счет того, что справа от `=` мы создаем массив из двух элементов и деструктурируем его в уже существующие переменные

### Свойств объекта

```javascript
({ firstname: user.lastname, lastname: user.firstname } = user);
```

- круглые скобки нужны, чтобы движок не воспринимал фигурные скобки как блок кода
- дальше принцип как в явном сопоставлении свойств и переменных
  - только мы исходные свойства извлекаем не в переменные, а в свойства этого же объекта. За счет этого происходит обмен
- работает за счет того, что при деструктуризации все свойства сначала читаются из объекта разом
  - т.о., при перезаписи свойства firstname мы не рискуем потерять исходное значение, потому что оно уже считано и запомнено



## Перебор свойств объекта

```javascript
let user = {
  name: "Tom",
  surname: "Sawyer",
  age: 14,
  state: "Missouri"
};

for (let [prop, value] of Object.entries(user)) {
  console.log(prop + ": " + value);
}
```



## Перебор элементов мапы

```javascript
let users = new Map([
  ["tom", 6000],
  ["huck", 6000],
  ["jim", 40]
]);

for (let [k, v] of users) {
  console.log(k + " " + v);
}
```





## Деструктуризация api-ответов

- со сложной структурой
  - удобно делается с помощью вложенной деструктуризации

```javascript
const response = {
  data: {
    user: {
      id: 1,
      profile: { firstName: 'John', lastName: 'Doe' }
    }
  },
  status: 200
};

// Извлекаем firstName и status:
const { 
  data: { 
    user: { 
      profile: { firstName } 
    } 
  }, 
  status 
} = response;

console.log(firstName, status); // John 200
```



## Дефолты для полей объекта

- можно использовать деструктуризацию как замену проверкам на заполненность *полей объекта*:

```javascript
// Ручные проверки с присвоением дефолтов
function greet(user) {
  const name = user.name || 'Guest';
  const age = user.age || 30;
  console.log(`Hello, ${name}! You are ${age}.`);
}

// С деструктуризацией проще:
function greet({ name = 'Guest', age = 30 }) {
  console.log(`Hello, ${name}! You are ${age}.`);
}

greet({ name: 'Alice' }); // Hello, Alice! You are 30.
```

