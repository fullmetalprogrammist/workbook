# hoisting

## База

- hoisting
  - это механизм, который "поднимает" идентификаторы до *верха* их *области видимости*
    - благодаря этому можно пользоваться идентификатором в любом месте блока
      - хорошо видно на примере функций

```js
foobar();  // <-- Можем вызывать функцию в начале скрипта

function foobar() {  // <-- хотя она объявлена в конце
  console.log('hello, hoisting!');
}
```

- говорят, что идентификатор "всплывает"
- hoisting работает для
  - function declaration
  - Переменных
    - объявленных через var
    - let, const
      - социально-приемлемо говорить, что let \ const -переменные не всплывают, потому что фактически пользоваться ими до инициализации нельзя
        - но технически на самом деле всплывают, просто находятся в "временной мертвой зоне", см в разделе "продвинутое"
- польза от hoisting
  - техническая
    - это надо спрашивать у тех, кто компиляторы разрабатывает
  - практическая
    - если у нас в скрипте описано много функций, то без hoisting надо четко следить, куда вписать функцию, чтобы ее описание было выше тех функций, которые ее используют

## Продвинутое

- во время компиляции движок узнает обо всех идентификаторах скрипта, где бы они ни были описаны (top-level, внутри функций, внутри блоков - не важно)
- на этапе компиляции создаются "шаблоны" (blueprint'ы) окружений, из которых при выполнении скрипта будут уже создаваться реальные экземпляры окружения
- обнаруженные идентификаторы попадают в эти шаблоны с определенными маркерами, в зависимости от того как они объявлены
- например

```js
// Глобальное окружение
let x = "hello";
console.log(foo);  // ✅ undefined
// console.log(y);    // ❌ ReferenceError: y is not defined

if (x) {  // Окружение if-блока
  var foo = "goodbye";
  console.log(y);  // ❌ ReferenceError: Cannot access 'y' before initialization
  let y = 10;
}

// Вывод:
undefined
Cannot access 'y' before initialization
```

- на этапе компиляции
  - **x** попадает в шаблон глобального окружения, 
    - т.к. **x** объявлен через let, то попадает с маркером TDZ (const тоже попадает в TDZ)
      - TDZ - Temporal Dead Zone, "временная мертвая зона"
        - этот маркер снимается, когда выполнение доходит до строки с инициализацией этого идентификатора
        - при попытке прочитать значение let-переменной до инициализации, благодаря маркеру TDZ движок понимает, что делать этого нельзя и возникает ошибка
  - **foo** тоже попадает в шаблон глобального окружения, т.к. var-переменные игнорируют блочную область видимости
    - попадает без маркера TDZ (потому что объявлена через var)
  - **y** попадает в шаблон окружения if-блока, с маркером TDZ
- на этапе выполнения
  - по мере достижения блоков создаются экземпляры окружений из шаблонов
  - в 3 строке все ок, потому что у var-переменных нет маркера TDZ, а за их значение в случае использования до инициализации, берется undefined
  - в 4 строке была бы ошибка, потому что идентификатора **y** нет в глобальном окружении
  - в 8 строке программа свалится, потому что у **y** маркер TDZ еще не снят, т.к. не дошло до инициализации



