# Как написать компонент

## Базовые требования к компонентам

- Правила именования компонентов
  - Компонент должен называться с большой буквы
    - Иначе могут быть технические проблемы
- Принцип "Один файл - один компонент"
  - Внутри файла может быть несколько вспомогательных "подкомпонентов", которые нужны основному
    - Но экспортироваться из файла должен единственный компонент
  - Имя файла должно совпадать с именем компонента
    - Расширение файла `.jsx` (или `.tsx` если используется TypeScript)
- Компоненты должны быть чистыми функциями
  - В top-level компонента никаких сайд-эффектов, это делается в хуках, вроде useEffect
- Компонент - это всегда отдельная функция, нельзя делать их в виде вложенных функций
- Разметка компонента должна быть завернута в единый блок, например div или `<>` (Fragment)
  - Потому что JSX-разметка трансформируется в объекты, вложенные друг в друга. Так что вернуть в разметке, например, два div, не завернутые в общий div, - все равно что пытаться вернуть из функции одновременно два значения, т.е. невозможно
  - Многострочную разметку оборачиваем круглыми скобками `return ( разметка )`



## Стиль описания компонента

- Функциональный компонент
  - Современно, с хуками
  - Синтаксис
    - [Function Declaration](оформление-компонента-react.md#function-declaration)
    - [Лямбда (это частный случай Function Expression)](оформление-компонента-react.md#лямбда)
- Классовый
  - легаси



## Импорт \ экспорт компонентов

- в react используется синтаксис импорта \ экспорта ES6
  - т.е. через import \ export
- способы экспорта (и правила импорта)
  - [дефолтный экспорт](оформление-компонента-react.md#дефолтный-экспорт)
    - синтаксис
      - одной строкой: объявление компонента + экспорт
        - не работает для компонентов-лямбд, только для FD
      - отдельно объявление, отдельно экспорт
    - на файл может быть строго один дефолтный экспорт
    - импорт
      - можно импортировать под любым именем
        - можно под исходным, можно под произвольным
  - [обычный экспорт](оформление-компонента-react.md#обычный-экспорт) ("именованный")
    - синтаксис
      - одной строкой: объявление компонента + экспорт
      - отдельно объявление, отдельно экспорт
    - импорт
      - можно импортировать только под исходным именем
        - но при импорте можно явно переименовать через `as`
  - смешанный экспорт
    - это когда в одном файле используется разом и дефолтный, и обычный экспорт
      - для компонентов не рекомендуется, т.к. нарушает принцип "один файл - один компонент"
      - если используется, то для экспорта каких-то утилит, констант, в общем надо конкретную ситуацию смотреть, насколько это оправдано



# Компоненты и данные

## Хранение данных компонента

- Состояние
  - ⚡Это данные, изменение которых приводит к ре-рендеру компонента
    - [useState](useState.md)
      - Инициализация
        - Значением
        - Функция, вычисляющая и в возвращающая значение
      - Изменение
        - Перезаписать состояние
        - Вычислить новое состояние на основе предыдущего
    - [useReducer](useReducer.md)
  - Принципы хранения состояния
    - Иммутабельность - заменяй, а не изменяй
      - Библиотека Immer
  - Место хранения состояния
    - В одном компоненте может быть много состояний
    - Эти состояния хранятся как список в fiber-узле
  - Механика изменения состояния
    - Изменение через хук > Запрос на фактическое изменение > Фактическое изменение > Ре-рендеринг
- ⚡Данные, изменение которых не приводит к ре-рендеру компонента
  - useRef
  - Можем мутировать эти данные

## Передача данных в компоненты

### Пропсы

- Все атрибуты (кроме некоторых, например ref и key), которые мы передаем в компонент, реакт собирает в единый объект
  - и передает его первым параметром в функцию компонента
    - этот параметр называется **props**
      - обычно его деструктурируют, чтобы не писать каждый раз `props.foobar`
- Пропсы бывают
  - ["Наши пропсы"](пропсы.md#наши-пропсы)
    - произвольные атрибуты, которые мы сами передаем в компонент
  - [Стандартные пропсы](пропсы.md#стандартные-пропсы)
    - по сути кроме children стандартных пропсов больше и нет
    - children
      - все вложенные в компонент элементы автоматически собираются в пропс children
      - удобно при создании разных "оберток", когда надо задать внешнюю форму, но дать клиенту компонента свободу определять содержимое
        - например
          - модальное окно - внешний вид задаем, а содержимое - за клиентом
          - кнопка - внешний вид определяем, а содержимое - за клиентом (может быть он захочет не просто подпись, а иконку + подпись или еще что-то более хитрое)
- [Проброс пропсов](пропсы.md#проброс-пропсов) в дочерний компонент `{...props}`
  - применяется, когда в дочернем компоненте нам нужны не все полученные пропсы, а только некоторые
    - при этом остальные пропсы "выбрасывать" нельзя, потому что они нужны в далее вложенных компонентах

### Направление передачи данных

- "Сверху вниз" - из родителя в дочерний компонент
  - Делается через пропсы
- "Снизу вверх" - из дочернего компонента в родительский
  - Через колбэк
    - Передаем дочке колбэк, а она вызывает его, передавая данные

### Передача данных в глубоко вложенные дочерние компоненты

- useContext
  - Контекст, провайдер контекста
  - Использование нескольких контекстов (вложение контекстов друг в друга)
  - Обновление значения в контексте



# Разновидности компонентов

## Управляемый и Неуправляемый компонент

- Терминология
  
  - Управляемый - Controlled, неуправляемый - Uncontrolled
  - Мб нагляднее было бы называть их "Контролируемый" и "Неконтролируемый", т.к. эти слова больше подходят к идее "контроль над значением"
- [Ключевое отличие управляемого от неуправляемого компонента](управляемый-и-неуправляемый-компонент-react.md#управляемый-vs-неуправляемый-компонент)
- Критерий "управляемости" - ответ на вопрос "реакт контролирует значение компонента или нет?"
  
  - если реакт устанавливает компоненту данные (например через value в случае input)
      - т.е. как бы "контролирует", что компонент показывает ("вот тебе значение, отображай его!")
        - тогда компонент **управляемый**
      - полная синхронизация данных из элементов интерфейса с состоянием компонента
            - изменяется состояние - изменяется интерфейс; изменяется интерфейс - изменяется состояние
      
    - если реакт не устанавливает компоненту данные
      - и компонент просто показывает то, что содержится в DOM-элементе
        - то реакт как бы "не контролирует" это значение
          - тогда компонент **неуправляемый**
            - нет синхронизации данных между элементами интерфейса и состоянием компонента
              - когда данные нужны, надо вручную получать их через ссылки на элементы
- Реализация
  - ⚡[Управляемый компонент](управляемый-и-неуправляемый-компонент-react.md#управляемый-компонент)
    - через useState
    - в change-обработчиках элементов вызываем функции изменения состояния
  - ⚡[Неуправляемый компонент](управляемый-и-неуправляемый-компонент-react.md#неуправляемый-компонент)
    - через useRef
    - Сохраняем ссылку на реальный DOM-элемент (ref + useRef)
      - кладем ref-объект в атрибут ref у компонента
      - когда нужны данные, получаем их напрямую из элемента с помощью этой ссылки
    - тонкости
      - [Проброс ref](управляемый-и-неуправляемый-компонент-react.md#явный-проброс-ref) в самописный компонент
        - делается с помощью функции `React.forwardRef`
        - Зачем делать проброс?
          - Техническая причина
            - ref - это системный атрибут, поэтому он не попадает в пропсы
              - поэтому надо делать явно проброс
                - можно прокинуть через обычный пропс "вручную", но через React.forwardRef это канонично и гарантированно не вызовет скрытых проблем
          - Концептуальная причина
            - фактический интерфейс состоит из конечных "примитивных" компонентов, вроде button, input
              - только они имеют реальный DOM-элемент
              - поэтому если положить объект в ref-атрибут примитивного компонента, реакт сохранит в этот объект ссылку на реальный DOM-элемент
            - все наши "самописные" компоненты - просто контейнеры для примитивов
              - соответственно, "самописные" компоненты не имеют реального DOM-элемента
              - и если положить объект в ref-атрибут самописного компонента, то никакой ссылки в нем не будет
            - поэтому, если в родителе надо сохранить ссылку на примитивный компонент, который завернут в самописный дочерний компонент, надо useRef-объект "прокинуть" в дочку и там уже положить в ref примитива
              - т.о. у родителя окажется ссылка на реальный DOM-элемент, который находится в дочке



# Жизненный цикл компонента

- Этапы жизненного цикла компонента
  - Монтирование
  - Рендеринг (первичный и ре-рендеринг)
  - Размонтирование
- Выполнить функцию на желаемом этапе жизненного цикла (useEffect)
  - Для разных целей, например
    - Предварительная загрузка данных для отображения.
    - Различные действия по очистке (отписка от событий)
    - И т.д.



# Уникальность компонента

- Зачем реакту различать компоненты
  - Чтобы понимать, когда можно использовать компонент повторно
    - Без этого компонент приходится создавать заново, а это снижает производительность
- Уникальность компонента базово определяется по
  - позиции компонента в fiber-дереве
  - по типу компонента
- Как влиять на уникальность
  - У компонента есть атрибут `key`, через которое можно задать ему уникальный идентификатор
    - Благодаря key реакт сможет сравнивать элементы не по позиции в дереве, а по идентификатору
- Правила задания `key`
  - key должен быть уникальным в пределах *соседних* элементов
    - например, если в компоненте два списка, то ключ не обязан быть уникальным сразу в двух
  - key должен быть статичным, т.е. не меняться в пределах жизни компонента
    - в идеале это какой-то id из БД
    - плохой ключ: индекс элемента в массиве, т.к. при добавлении \ удалении элементов индекс существующих элементов меняется
  - key может быть только числом или строкой
- Особенности key
  - key - это системный атрибут, он не попадает в пропсы
- Примеры пользы уникальности
  - [Списки однотипных элементов (товары, пользователи)](уникальность-компонента-react.md#списки-элементов)
    - элементы списка при сортировке меняют свой порядок, но по сути не изменяются, значит эффективнее будет их использовать повторно
  - TODO: списки - не единственный полезный сценарий, дописать позже про другие



# Стилизация компонента

- Использование css-стилей в компоненте.



