# Состояние и фрагменты состояния

```javascript
// ⭐ ЦЕЛОЕ СОСТОЯНИЕ (State) - ПЛОСКАЯ СТРУКТУРА
const state = {  
  // Фрагмент "Персональная информация"
  person: {
    firstname: "Иван",
    lastname: "Иванов", 
    birthDate: "1990-01-15"
  },
  
  // Фрагмент "Контакты"
  contacts: {
    phone: "+79991234567",
    email: "ivan@mail.ru",
    address: "г. Москва, ул. Пушкина, д. 10"
  },
  
  // Фрагмент "Семья" 
  family: {
    mother: { name: "Мария Иванова" },
    father: { name: "Петр Иванов" },
    children: [
      { name: "Сергей", age: 5 }
    ]
  },
  
  // Фрагмент "Стаж"
  experience: [
    {
      company: "ООО Ромашка",
      position: "Разработчик",
      years: "2015-2020"
    },
    {
      company: "АО Лютик",
      position: "Старший разработчик", 
      years: "2020-н.в."
    }
  ]
};
```



# Действие

- Формат `domain/ACTION_NAME`

```javascript
const updateNameAction = {
  type: 'person/UPDATE_FIRSTNAME',
  payload: 'Петр'
};
```

```javascript
const addChildAction = {
  type: 'family/ADD_CHILD',
  payload: {
    name: 'Ольга',
    age: 2
  }
};
```

```javascript
const addExperienceAction = {
  type: 'experience/ADD_ITEM',
  payload: {
    company: 'ИП Васильев',
    position: 'Team Lead',
    years: '2024-н.в.'
  }
};
```





# Action creator

- Чтобы не писать руками объекты действий, не ошибиться в их типах, делаем action creator'ы:

```javascript
const updateName = (firstname) => ({  // lambda-style
  type: 'person/UPDATE_FIRSTNAME',
  payload: firstname
});
```

```javascript
function addChild(childData) {  // fd-style
  return {
    type: 'family/ADD_CHILD',
    payload: childData
  }
};
```

- И пользуемся ими в местах, где нужно создать действие:

```javascript
dispatch(updateName('Петр'));
dispatch(addChild({ name: 'Ольга', age: 2 }));
```





# Редюсер

## Редюсер для фрагмента person

### Redux

```javascript
const initialState = {
  firstname: "Иван",
  lastname: "Иванов", 
  birthDate: "1990-01-15"
};
```

В ванильном Redux указание стартового значения и прописывание типов действий, на которые реагирует редюсер, делается вручную:

```javascript
const personReducer = (state = initialState, action) => {
  switch (action.type) {
    case 'person/UPDATE_PERSON':  // можно обновить фрагмент целиком
      return { ...state, ...action.payload };  // например, если разом меняется имя + фамилия
    
    case 'person/UPDATE_FIRSTNAME':  // а можно частями
      return { ...state, firstname: action.payload };
    
    case 'person/UPDATE_LASTNAME':
      return { ...state, lastname: action.payload };
    
    case 'person/UPDATE_BIRTHDATE':
      return { ...state, birthDate: action.payload };
    
    default:
      return state;
  }
};
```

### RTK

- В RTK настройка редюсера на действия происходит автоматически, в [слайсе](#слайсы)





# Корневой редюсер

## Redux

- В ванильном Redux корневой редюсер создается отдельной функцией `combineReducers`

```javascript
import { combineReducers } from 'redux';
import { createStore } from 'redux';

export const rootReducer = combineReducers({
  person: personReducer,  // <-- "Person-фрагмент" попадет в итоговое состояние в поле person
  experience: reducerExperience,  // <-- "Experience-фрагмент" попадет в поле experience
  contacts: foobar,  // <-- Просто показать, что имя поля определяет, куда попадет фрагмент, а не имя редюсера
  family: qwerty
});

const myStore = createStore(rootReducer);  // <-- Передаем КР хранилищу
```

## RTK

- В RTK корневой редюсер задается среди прочих параметров при создании хранилища

```javascript
import { configureStore } from "@reduxjs/toolkit";

const myStore = configureStore({
  reducer: { 
    person: reducerPerson,
    experience: reducerExperience
  }
});
```





# Слайсы

## Слайс для фрагмента person

- Пример слайса для фрагмента person:

```javascript
import { createSlice } from '@reduxjs/toolkit';

const initialState = {
  firstname: "Иван",
  lastname: "Иванов", 
  birthDate: "1990-01-15"
};

const personSlice = createSlice({
  name: 'person',  // <-- domain
  initialState,  // <-- Указываем начальное значение для фрагмента состояния
  reducers: {  // <-- Пишем функции для обработки действий
    setFirstname: (state, action) => {  // <-- тип действия будет person/setFirstname
      state.firstname = action.payload;  // <-- с виду мутация, но Immer делат новый объект
    },
    
    setLastname: (state, action) => {  // <-- person/setLastname
      state.lastname = action.payload;
    },
    
    setBirthDate: (state, action) => {  // <-- person/setBirthDate
      state.birthDate = action.payload;
    },
    
    updatePerson: (state, action) => {  // <-- person/updatePerson
      return {
        ...state,
        ...action.payload
      };
    }
  }
});
```

- Извлекаем из слайса action creator'ы и общий редюсер

```javascript
// Извлекаем и экспортируем экшены
export const { 
  setFirstname,   // <-- action creator
  setLastname, 
  setBirthDate, 
  updatePerson 
} = personSlice.actions;  // <-- Технически, это не действия, а action creator'ы

// Извлекаем и экспортируем редюсер
export default personSlice.reducer;  // <-- Его отдадим в корневой редюсер
```

```javascript
// Пример использования
dispatch(setFirstname("Петр"));
```

## Механики слайса

- В name указываем имя слайса. Технически - произвольное, но логично называть по имени фрагмента состояния, за который отвечает слайс

  - name участвует в формировании типа действия

- В свойстве reducers мы, несмотря на название, пишем не редюсеры, а просто функции по обработке действий

  - На основе этих функций слайс сгенерирует action creator'ы и редюсер

    - Достать AC из слайса можно через свойство `.actions`
      - Важно понять, что setFirstname, setLastname и т.д. возвращают нам не функции из reducers как есть, а функции на их основе, в которых будет единственный аргумент - нагрузка
  - Достать редюсер из слайса можно через свойство `.reducer`
  
- Как формируется редюсер
  
  - Тип действия формируется по формуле `имяСлайса/имяФункции`
  
  - Т.о. можно представить, что слайс за нас написал редюсер, в котором есть
  
      ```javascript
      switch(action.type) {
        case 'person/setFirstname': {
          state.firstname = action.payload;
          break;
        }
        // остальные ветки для обработки других действий
    ```
  
      



# Хранилище

## Создание хранилища

### Redux

```javascript
import { createStore } from 'redux';

const rootReducer = // Создаем корневой редюсер, см. соотв раздел

const myStore = createStore(rootReducer);
```

### RTK

```javascript
import { configureStore } from "@reduxjs/toolkit";

const myStore = configureStore({
  reducer: { 
    // Создаем корневой редюсер, см. соотв раздел
  }
});
```

## Подключение хранилища к приложению

- Оборачиваем все приложение в провайдер
  - Отдаем провайдеру хранилище

```jsx
import { Provider } from 'react-redux';

const myStore = // создаем хранилище

export default function ReduxBasicDemo() {
  return (
    <Provider store={myStore}>
      <App />
    </Provider>
  );
}
```





## Чтение из хранилища

```jsx
import React from 'react';
import { useSelector } from 'react-redux';

const PersonInfo = () => {
  const person = useSelector(state => state.person);  // <-- Подписываемся на нужные данные

  return (
    <div>
      <p>Имя: {person.firstname}</p>
      <p>Фамилия: {person.lastname}</p>
      <p>Дата рождения: {person.birthDate}</p>
    </div>
  );
};

export default PersonInfo;
```





## Запись в хранилище

```jsx
import React, { useState } from 'react';
import { useDispatch } from 'react-redux';
import { setFirstname, setLastname, setBirthDate, updatePerson } from './personSlice';

const PersonEditor = () => {
  const dispatch = useDispatch();  // <-- Получаем функцию-диспетчер от редакса
    
  const [formData, setFormData] = useState({  // <-- Локальное состояние для хранения ввода из формы
    firstname: '',
    lastname: '',
    birthDate: ''
  });

  const handleChange = (e) => {  // <-- Сохраняем значение в локальное состояние компонента
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
  };

  const handleSave = () => {
    dispatch(updatePerson(formData));  // <-- Отправляем действие в редакс через диспетчера
  };

  return (
    <div>
      <div>
        <label>Имя:</label>
        <input name="firstname" value={formData.firstname} onChange={handleChange} />
      </div>
      
      <div>
        <label>Фамилия:</label>
        <input name="lastname" value={formData.lastname} onChange={handleChange} />
      </div>
      
      <div>
        <label>Дата рождения:</label>
        <input name="birthDate" type="date" value={formData.birthDate} onChange={handleChange} />
      </div>

      <button onClick={handleSave}>
        Сохранить все данные
      </button>
    </div>
  );
};

export default PersonEditor;
```





