# origin

- `Ориджин` - это комбинация `протокол + хост + порт`
  - Ориджин нужен, чтобы понимать, откуда загружен ресурс (например страница, скрипт)
  - Так что при сравнении ориджинов происходит сравнение этих трех компонентов
  - Если хотя бы один компонент отличается, ориджины считаются разными
- Например, у https://my-app.com ориджин это https://my-app.com:443 (дефолтный порт для https)
  - У https://my-app.com и  https://api.my-app.com разные ориджины, т.к. хосты разные (my-app.com и api.my-app.com)
  - Нюанс
    - Если например выполнить `console.log(window.origin)`, то выведется https://my-app.com, потому что если порт стандартный, то "текстовое представление" ориджина порт опускает
    - Но это не значит, что порт не входит в ориджин. При сравнении это строго протокол + хост + порт. Надо помнить, чтобы не ввестись в заблуждение текстовым выводом.
- На русский ориджин иногда переводится как `источник`



# Кросс-доменный запрос

- Кросс-доменный запрос - это когда скрипт, загруженный с одного ориджина, шлет запрос на другой ориджин
  - Грубо говоря, зашли на microsoft.com, а на его странице прикреплен скрипт (тоже загружается с microsoft.com), который шлет запрос на apple.com. Получается кросс-доменный запрос
- В чем проблема кросс-доменных запросов?
  - Наивный пример для понимания сути
    - P.S. Пример показывает, как дело обстояло на заре, до появления механизмов защиты. Сейчас такая атака не пройдет
    - Я авторизовался на сайте банка, сервер выслал моему браузеру идентификатор, браузер сохранил этот идентификатор в куку
    - Я сижу на сайте, перехожу по страницам, браузер исправно прикладывает куку к моим запросам, за счет чего сервер понимает, что я это я
    - Тут я открываю новую вкладку, захожу на какой-то скам-сайт, а на сайте - скрипт, который отправляет в банк запрос, например, "сколько у меня денег на счету" и "какой номер телефона привязан к аккаунту"
    - Браузер видит, что запрос для сервера банка и прикладывает куку
    - Банк запрос принимает, видит куку, и отправляет ответ с моим балансом и номером телефона
    - Скрипт на скам-сайте читает ответ и сохраняет мой баланс и номер телефона в скамерскую БД
    - Поздравляем! Я, ничего не подозревая, отдал мошенникам информацию и своем финансовом положении



# SOP

- `Same-Origin Policy` - это политика *браузера* по ограничениям для кросс-доменных запросов.
- Ограничений несколько:
  - Браузер не дает скрипту читать ответы сервера на кросс-доменные запросы
    - Например, в наивном примере с банком, хотя сервер ответит на скам-запрос и вышлет мой баланс и телефон, но браузер не даст скрипту прочитать ответ
  - Скрипт не может работать с DOM других вкладок, если они относятся к другому ориджину
  - Скрипт не может работать с куками \ localStorage другого ориджина
    - P.S. куки \ localStorage группируются по ориджину, а не по вкладками, т.е. у каждого ориджина (а не у каждой вкладки) свой набор кук и свой localStorage
  - Мб что-то еще
- Особенности SOP
  - SOP не блокирует возможность отправки кросс-доменного запроса
    - Т.е. он дает защиту от атаки-вопроса "покажи, какой у меня баланс", но не дает защиту от атаки-команды "переведи все мои деньги на безопасный счет"



# CORS

- `CORS` - Cross-Origin Resource Sharing

- Это политика браузера для ослабления SOP в ситуациях, когда это нужно

- Пример ситуации, когда SOP мешает

  - Сделали приложение, опубликовали на https://superapp.com
  - Сделали API, опубликовали на https://api.superapp.com (субдомен)
  - Шлем из приложения запросы на api и не можем прочитать ответы, потому что хосты разные, и SOP не дает скрипту читать

- Как CORS помогает решить ситуацию? 

  - Сервер может добавить специальный заголовок 

    ```java
    response.setHeader('Access-Control-Allow-Origin', 'https://superapp.com');
    ```

  - Браузер, когда видит такой заголовок, разрешает скрипту, загруженному с ориджина https://superapp.com, читать ответ

  - Т.о. сервер явным образом может через заголовки ответа сообщить браузеру, кому можно читать ответы

  - Заголовок `'Access-Control-Allow-Origin': '*'` позволяет любому скрипту читать ответ

    - Это удобно для публичных API



# Атака CSRF

- `CSRF` - Cross-Site Resource Forgery
  - "Межсайтовая подделка запроса"
- Наивный пример для понимания сути атаки
  - Я зашел на свою страницу в социальной сети, авторизовался
  - Сервер передал моему браузеру мой идентификатор
  - Браузер сохранил идентификатор в куку
  - Я сижу на сайте, смотрю фотки, читаю новости, браузер при каждом запросе отсылает куку серверу, за счет чего он понимает, кто я
  - Я открыл новую вкладку и зашел на скам-сайт
  - На этом сайте скрипт, который шлет на сервер социальной сети запрос, например, на публикацию на моей стене сообщения "Попал в беду, срочно скиньте пожалуйста кто сколько может денег мне на карту 1337228322"
  - Браузер, как и положено, автоматически цепляет к этому запросу куку с моим идентификатором
  - Сервер получает запрос, видит что кука с идентификатором есть, и выполняет публикацию сообщения
  - Особо сердобольные друзья начинают скидывать скамеру деньги на карту, пока я не замечу сообщение и не удалю его





# Атака XSS

- `XSS` - Cross-Site Scripting
- Это тип атаки, когда вредоносный скрипт внедряется в "официальную" страницу, и жертвам даже не надо переходить ни на какие скам-сайты - их скамит сам "официальный сайт"
  - XSS даже в современном мире до сих пор является одной из наиболее типичных и распространенных атак, с которой трудно бороться
- Базовый пример внедрения для понимания идеи атаки
  - "Грязный ввод"
    - Например, на странице можно оставлять комментарии
    - Злоумышленник пишет "Отличная фотка! `<script>скайнет запускает ракеты здесь</script>`" и отправляет комментарий
    - Если сервер сохранит этот текст в БД как есть, то следующие пользователи, которые зайдут на страницу, станут жертвами атаки, т.к. сервер загрузит комментарии, браузер увидит тег `<script>` и честно его выполнит (никто об этом не узнает, потому что содержимое скрипта не отображается визуально в DOM)
    - Поэтому весь пользовательский ввод надо экранировать и пропускать через `санитайзеры`, которые преобразуют текст таким образом, чтобы он не мог выполниться
      - Экранирование - это замена спецсимволов (вроде угловых скобок `<` и `>`) на особые коды, в результате чего браузер воспринимает их как обычный текст
      - Санитайзинг - это преобразование ввода так, что из него либо удаляются потенциально опасные блоки, либо модифицируются, и в итоге ввод перестает быть опасным
- Виды XSS-атак
  - Хранимая атака (stored) - как в примере с комментарием
    - Суть в том, что вредоносный код сохраняется на сервере
  - Отраженная атака (reflected)
    - Суть в том, что вредоносный код уходит на сервер, но не сохраняется на нем, а возвращается клиенту в ответе. Как бы "отражается" от сервера
      - Часто способом доставки является url
        - Например, злоумышленник формирует ссылку поиска товара `https://petshop.com/search?q=<script>the matrix has you</script>` и кидает ее жертве (замаскировав код, это отдельная тема) "Смотри, какие классные комбинезоны для собак!"
        - Жертва переходит по ссылке, сервер возвращает, например, html-ответ где планировалось отображать результат поиска, вроде "Извините, по вашему запросу [тут могло быть КОМБИНЕЗОН, но тут скрипт, и он визуально не отображается, а просто выполняется] ничего не найдено"
  - DOM-based XSS

