---
title: "Промисы"
layout: default
parent: "JavaScript"
---



# Карта

- [Базовый синтаксис промиса](#базовый-синтаксис-промиса)
  - Выполнение - синхронное, обработка результата - асинхронная
    - "Промис - это "обертка для значения, которого еще нет, но появится в будущем""
  - Выполнение промиса
    - Конструктор промиса
      - Принимает колбэк ("**экзекутор**") - код, который мы хотим выполнить в промисе
        - У экзекутора два параметра
          - Это функции
            - Общепринятые названия для них
              - `resolve`
              - `reject`
            - Вызов любой из них приводит к завершению промиса
        - Промис вызывает экзекутор внутри своего конструктора
          - Поэтому специально запускать промис в работу не надо
            - Т.е. создание промиса сопряжено с вызовом экзекутора
          - P.S. Функции resolve \ reject промис создает внутри своего конструктора и передает их в наш экзекутор при его вызове
    - Промис выполняется единожды
      - Повторно запустить его невозможно
  - Завершение промиса
    - Два варианта завершения
      - "Успех"
      - "Провал"
    - Для завершения вызываем resolve *или* reject
      - `resolve(значение)` - для успешного завершения промиса
        - Передаем значение, которое хотим вернуть как итог работы
      - `reject(error)` - для отклонения промиса, "неуспешное" завершение
        - Передаем причину неуспешного завершения
          - Обычно это объект ошибки
    - Вызов resolve \ reject сам по себе не делает выход из экзекутора
      - Но лучше строить код так, чтобы экзекутор заканчивался этими вызовами, чтобы не было путаницы
        - Именно "прервать" экзекутор можно вызовом return
    - Результат промиса
      - Технически, и "значение", и "ошибка", переданные в resolve \ reject, являются результатом
        - Т.е. деление логическое, технически это хранится одинаково
          - Результат хранится в системном поле `[[PromiseResult]]`
            - Получить доступ к результату напрямую из объекта промиса - нельзя
      - [Получение результата](#получение-результата)
        - Нужны методы промиса `then` \ `catch`
          - Они принимают колбэки ("**подписчики**")
            - Подписчики хранятся в системных полях промиса
              - `[[PromiseFulfillReactions]]` - подписчики на успешное завершение промиса
              - `[[PromiseRejectReactions]]` - подписчики на отклонение промиса
          - Подписчики автоматически вызываются после завершения промиса
            - У подписчика единственный параметр - через него он получает результат
          - `.then(onFullfilled, onRejected)`
            - Два параметра
              - onFullfilled - подписчик на успешное завершение
              - onRejected - подписчик на отклонение
          - `.catch(onRejected)`
            - Один параметр
              - onRejected - подписчик на отклонение
    - [Освобождение ресурсов](#освобождение-ресурсов)
      - Метод `finally(onFulfilledAndRejected)`
        - Подписчик, добавленный через finally, результат не получает
          - Подписчик выполняется при любом завершении промиса, что при резолве, что при отклонении
            - Нужен для выполнения "очистки", "освобождения ресурсов"
              - Закрытие файлов, сетевых соединений и т.д.
  - Статусы промиса
    - Всего 3 возможных статуса
      - `pending` - начальный статус. Будет до тех пор, пока не вызваны resolve \ reject
      - `fullfilled` - статус после вызова resolve (промис завершен успешно)
      - `rejected` - статус после вызова reject (промис "отклонен")
    - Статус хранится в системном поле промиса `[[PromiseState]]`
      - Явно прочитать его нельзя
      - Изменить вручную нельзя
      - Это внутренняя механика промиса, с ним непосредственно работают только собственные методы промиса
  - Цепочки методов then \ catch \ finally
    - Методы then \ catch \ finally возвращают новый промис
      - Поэтому эти методы можно писать цепочками
      - Технически, finally не обязательно писать в самом конце
  - [Ошибки в промисах](#ошибки-в-промисах)
    - Синхронные
      - Непойманная ошибка в колбэке - это все равно что отклонить промис с этой ошибкой
    - Асинхронные
      - Если ошибка возникает асинхронно, например, в колбэке поставили setTimeout и внутри него ошибка, промис эту ошибку поймать технически не может
    - Прочие кейсы
      - [Отклонение промиса без обработки](#отклонение-без-обработки)
        - Не кладут программу (пока что, потом это поведение могут изменить)
        - TODO дописать \ доразобраться
- API промисов





<h1>Оглавление</h1>
- TOC
{:toc}





# Базовый синтаксис промиса

```javascript
new Promise((resolve, reject) => {  // <-- Экзекутор передаем в конструктор
  let num = Math.random() * 10;

  if (num >= 7) { 
    resolve(num);  // <-- Успешно завершаем промис, передаем результат
  }
  else if (num >= 4) {
    // <-- "Провально" завершаем промис, передаем ошибку
    reject(new Error("Полученное число недостаточно большое."));
  }
  else {
    // <-- Автоматически вызывается reject с этой непойманной ошибкой
    throw new Error("Произошла непредвиденная ошибка.");
  }
})
  .then(result => console.log(result))  // <-- Добавляем подписчика на успешное выполнение
  .catch(error => console.log(error))  // <-- Добавляем подписчика на отклонение
  .finally(() => console.log("Освобождаем ресурсы"));  // <-- Подписчик выполнится при любом результате
```





# Получение результата

## Метод .then

```javascript
prom.then(
  result => console.log(result),       // Выполнится, если промис fulfilled
  error => console.log(error.message)  // Выполнится, если промис rejected
);
```

Можно передать единственную функцию, только под успешное завершение, а ошибку ловить отдельным методом catch:

```javascript
prom.then(
  result => console.log(result)
);
```

## Метод .catch

```javascript
prom.catch(
  error => console.log(error.message)
);
```

По сути, catch это аналог вот такой конструкции:

```javascript
prom.then(
  null,
  error => console.log(result.message)
);
```

Преимуществом использования catch является то, что если написать вот так:

```javascript
new Promise((resolve, reject) => {
  foobar();
})
  .then(result => console.log(result))
  .catch(error => console.log(result.message));
```

То мы поймаем ошибку в двух местах:

- Если она возникнет в исходном промисе
- Если она возникнет в колбэке из then

При возникновении ошибки она проскакивает все звенья цепочки до первого попавшегося catch (или then, у которого есть второй колбэк). Если там ее не обработать, она полетит до следующего catch и так до тех пор, пока цепочка не закончится. Если в итоге ее так и не обрабоать, то программа не ляжет, но движок сгенерирует событие unhandledrejection. Подробнее об этом в отдельном конспекте, посвященном ошибкам в промисах. А понять, каким образом технически "ошибка перемещается по звеньям цепочки", можно из конспекта по механике промисов и про цепочки промисов.



# Освобождение ресурсов

## Метод .finally

```javascript
prom.finally(onFulfilledAndRejected);
```

```javascript
prom
  .finally(() => console.log("Освобождение ресурсов"))
  .then(result => console.log(result))
  .catch(error => console.log(error.message));
```

Идейно finally нужен для выполнения каких-то общих действий, не зависящих от того, как завершился промис. Например, закрытие файлов, сетевых соединений и т.д. 

Может показаться странным, что finally() тут идет перед then. Однако технически ничего странного нет. Поскольку каждый из методов then, catch, finally тоже возвращает промис (подробнее об этом в будущих конспектах), то finally можно писать в любом месте цепочки в зависимости от того, где это надо.

finally ничего не должен возвращать, а даже если возвращает, то это значение не попадает в последующие методы. При этом finally не "глотает" полученное от предыдущего промиса значение:

```javascript
Promise.resolve(5)  // <-- Результат работы промиса - 5
  .finally(() => return 10)  // <-- Пытаемся перекрыть результат исходного промиса
  .then(result => {
    console.log(result);  // 5, т.е. finally не "проглотил" результат исходного промиса
  });
```

Подробнее о технической стороне этих методов - другом конспекте.





# Ошибки в промисах

## Синхронные

В исходном промисе:

```javascript
new Promise((resolve, reject) => {
  console.log("Работает экзекутор.");
  console.log("Вызовем ошибку в экзекуторе и не будем ее обрабатывать.");
  throw new Error("Эту ошибку промис поймал сам и отклонился.");
})  
  .catch(error => {
    console.log("Работает catch.");
    console.log(error.message);
  });
// Вывод:
// "Работает экзекутор." 
// "Вызовем ошибку в экзекуторе и не будем ее обрабатывать." 
// "Работает catch." 
// "Эту ошибку промис поймал сам и отклонился." 
```

В подписчике:

```javascript
new Promise((resolve, reject) => {
  resolve();
})
  .then(result => {
    throw new Error("Необработанная ошибка в подписчике.");  // <-- Ошибка в подписчике.
  })
  .catch(error => {
    console.log("Работает catch.");
    console.log(error.message);
  });

//  Работает catch.
//  Необработанная ошибка в подписчике.
```

## Асинхронные

Важный момент касательно ошибок в промисах. Если написать вот так:

```javascript
new Promise((resolve, reject) => {
  setTimeout(() => { 
    console.log("Сейчас будет ошибка, возникшая асинхронно, и промис ее не поймает");
    throw new Error("Асинхронная ошибка.");  // <-- throw в setTimeout
  }, 0);
})
  .catch(error => console.log(error.message));
```

то в catch она не попадет. Хотя не поймать ошибку в экзекуторе - это все равно, что отклонить промис с этой ошибкой, но есть нюанс - ошибки "ловятся автоматически" только если происходят непосредственно в коде экзекутора.

Здесь же в коде экзекутора выполняется setTimeout, т.е. лишь операция планирования макрозадачи и никаких ошибок нет. Ошибка происходит внутри этой макрозадачи, которая к нашему промису никакого отношения не имеет, кроме того что он просто ее создал.

Чтобы лучше понимать техническую часть, почему это так работает, надо прочитать конспект про Event Loop, про микро- и макрозадачи. Применительно к этому примеру суть такова: в теле промиса создается макрозадача. Когда скрипт (который сам по себе тоже является макрозадачей) отрабатывает, то начинают обрабатывается *микро*-задачи, в данном случае это колбэк из метода catch. И только когда все микро-задачи обработаются, начинает выполняться следующая макрозадача, т.е. функция, которую мы закинули в setTimeout.

Получаем следующие факты:

* Ошибка возникает не в самом промисе, а в задаче, которая выполнится в будущем. В промисе же эта задача просто запланирована.
* Колбэк из catch технически выполнится до того, как начнет работу запланированная через setTimeout задача, т.е. фактически до возникновения ошибки. Так что в любом случае невозможно было бы в нем обработать эту ошибку, потому что она еще не возникла.

Так что потенциальные ошибки в асинхронном коде надо ловить самостоятельно, например:

```javascript
new Promise((resolve, reject) => {
  setTimeout(() => { 
    try{
      throw new Error("Асинхронная ошибка поймана.");  // <-- throw в setTimeout
    } catch (error) {
      reject(error);
    }
  }, 0);
})
  .catch(error => console.log(error.message));
// Вывод:
// "Асинхронная ошибка поймана."
```



# Отклонение без обработки

## Отклоненный промис без catch

Если промис отклоняется, но нет обработчика отклонения (не приделали его через then или catch), тогда движок запомнит такой промис и выдаст сообщение в консоль. Например:

```javascript
new Promise((resolve, reject) => {
  reject(new Error("Движок отслеживает отклоненные промисы, которые не были обработаны."));
});

// Uncaught (in promise) Error: Движок отслеживает отклоненные промисы, которые не были обработаны.
```

Это помогает избежать "тихих ошибок", которые возникают, но никак не визуализируются. В данный момент необработанные отклоненные промисы не кладут программу, но это поведение может измениться в будущем. Поэтому к отклонению промиса надо относиться как к обычной потенциальной ошибке в синхронном коде и добавлять обработку для избежания проблем:

```javascript
new Promise((resolve, reject) => {
  reject(new Error("Движок отслеживает отклоненные промисы, которые не были обработаны."));
})
  .catch(error => console.log("Обработали отклоненный промис, движок не беспокойся."));
```

## Момент поиска необработанных отклонений

Когда движок проверяет, есть ли отклоненные промисы без обработчиков отклонения? Он делает это после выполнения всех микрозадач, но до рендера.

## Глобальная обработка необработанных промисов

Когда движок находит необработанный промис, он генерирует событие `unhandledrejection` и таким образом мы можем обрабатывать пропущенные ошибки:

```javascript
window.addEventListener("unhandledrejection", (e) => {
  console.error("Поймал необработанный промис:", e.reason);
});

new Promise((resolve, reject) => {
  reject(new Error("Ошибка в промисе."));
});
```

Особенности:

* Важно добавлять обработчик до того, как промис отклонится.
* Событие срабатывает на каждый отклоненный без обработки промис. Т.е. если таких промисов 5, то и событие сработает 5 раз.

P.S. Этот код у меня почему-то не работал, хотя должен. Не стал возиться, оставлю до момента, когда ситуация реально будет требовать разобраться.

## Отложенная обработка

Когда мы обрабатываем промис, который изначально был отклонен без обработки, через событие unhandledrejection, то возникает другое событие - `rejectionhandled`:

```javascript
window.addEventListener("rejectionhandled", (event) => {
  console.log("Ошибка теперь обработана:", event.reason);
});
```

Такое может случиться, когда catch на промис добавляется не сразу, а потом, например:

```javascript
window.addEventListener("rejectionhandled", (event) => {
  console.log("Ошибка теперь обработана:", event.reason);
});

const p = Promise.reject(new Error("Позже обработаем."));

setTimeout(() => {
  p.catch(() => { console.log("Обработали отклоненный промис.") }); // <-- Обрабатываем позже.
}, 1000);
```

