---
title: "Деструктурирующее присваивание"
layout: default
parent: "Продвинутый синтаксис"
---



<h1>Оглавление</h1>
- TOC
{:toc}



# Карта

## Деструктурирующее присваивание

- или просто "деструктуризация" для краткости
- это один из способов извлечь данные из массивов, объектов, мап, сетов, строк
- деструктуризацию можно применить к
  - объекту
  - любому iterable-контейнеру
- с оригинальным "контейнером" \ объектом ничего не происходит
  - слово "деструктуризация" не подразумевает какой-то "распад" источника

## Базовый синтаксис

- iterable (массивы, мапы, сеты, строки) - через `[ ]`
  - `let [item1, item2] = container;`
- объекты - через `{ }`
  - `let { name, age } = person;`
- как запомнить синтаксис?
  - массивы создаются с помощью `[ ]`
    - и дестрачатся тоже квадратными скобками
  - объекты создаются с помощью `{ }`
    - и дестрачатся тоже фигурными скобками
- дополнительно
  - то, что слева от `=`, называется "шаблон деструктуризации"
  - если в iterable не хватает элементов, чтобы заполнить переменные, то переменные будут undefined
    - аналогично, если в объекте не будет указанных свойств, то переменные тоже будут undefined

## Дополнительные возможности

- [пропуск элементов](#пропуск-элементов)
  - iterable
  - объекты
- [деструктуризация в заранее объявленные переменные](#деструктуризация-в-заранее-объявленные-переменные)
  - iterable
  - объекты
- [сбор остатков в кучу](#сбор-остатков-в-кучу)
  - с помощью rest-оператора
  - iterable
  - объекты
- [значения по умолчанию](#значения-по-умолчанию)
  - iterable
  - объекты
    - особенно полезно в сложных объектах, чтобы не получать ошибки из-за `undefined.foobar`
- фишки для объектов
  - сопоставление свойств и переменных
    - автоматическое
    - явное
  - свап значений свойств
  - вложенная деструктуризация

## Практические примеры

- Свап переменных
- Извлечение отдельных свойств объекта
- Вложенная деструктуризация
- Извлечение нескольких значений из массива
- Указание значений по умолчанию

  





# Конспект

## Пропуск элементов

### iterable

- Просто вместо имени переменной не пишем ничего, оставляем голую запятую
- Пропуск элементов обычно полезен, когда в массиве лежат какие-то форматированные данные, например дата, разбитая на год, месяц, день и часть этих данных не нужна:

```javascript
const [, month, day] = "2025-04-28".split("-");
console.log(month);  // 04
console.log(day);    // 28
```

### объекты

- Просто указываем только те поля, которые нужны
- Практическая польза деструктуризации объекта в том, что не надо каждый раз обращаться к полям через точку:

```jsx
const formData = {
  username: 'john_doe',
  email: 'john@test.com',
  _token: 'abc123',
  _timestamp: 1620000000,
  _formId: 'registration'
};

const { username, email } = formData;  // <-- Извлекли "полезные" данные
console.log(username);  // <-- удобнее, чем formData.username
console.log(email);
```



## Деструктуризация в заранее объявленные переменные

### iterable

- просто переменные объявляются заранее, без нюансов

```javascript
let year, month, day;
[year, month, day] = "2025-04-28".split("-");
```

### объекты

- всю конструкцию деструктуризации надо брать в круглые скобки
  - иначе js принимает `{ }` за блок кода и получается ошибка

```javascript
const formData = {
  username: 'john_doe',
  email: 'john@test.com',
  _token: 'abc123',
  _timestamp: 1620000000,
  _formId: 'registration'
};

let username, email;
({ username, email } = formData);

console.log(username);
console.log(email);
```



## Сбор остатков в кучу

### iterable

- если какую-то часть данных при деструктуризации хочется собрать в единую группу, можно сделать это rest-оператором
  - данные соберутся в массив
- например, имя и адрес покупателя извлекаем в отдельные переменные, а заказанные товары объединяем в массив:

```javascript
const order = ["Иван Козлов", "ул. Революции 1", "iPhone", "AirPods", "Чехол", "Защитное стекло"];

let [customer, address, ...products] = order;
console.log(Array.isArray(products));   // true
```

### объекты

- часть свойств при деструктуризации объекта можно собрать в отдельный *объект*
- это часто бывает полезно в реакте
  - компонент деструктурирует пропсы, себе берет только нужные, а остальные собирает в объект и передает дальше

```jsx
function CustomButton({ primary, size, children, ...otherProps }) {
  // Для себя нужны primary, size, children
  // Остальные, сколько бы их ни было, - соберем в otherProps и прокинем дальше
  return (
    <button 
      className={`btn ${primary ? 'btn-primary' : ''} ${size}`}
      {...otherProps}
    >
      {children}
    </button>
  );
}

// Использование
<CustomButton primary size="large" onClick={handleClick} disabled={true}>
  Купить
</CustomButton>
```



## Значения по умолчанию

### iterable

```javascript
const userInfo = [];
const [firstname = "John", lastname = "Doe"] = userInfo;

console.log(`${firstname} ${lastname}`);  // "John Doe"
```

### объекты

- простые объекты

```javascript
const userInfo = {
  firstname: "Mike",
  lastname: "Hunt"
};

const { 
  firstname = "John",  // <-- При объявлении переменных, куда деструктурировать,
  lastname = "Doe",    // указываем значения по умолчанию
  role = "guest" 
} = userInfo;
console.log(`user: ${firstname} ${lastname}, role: ${role}`);  // "user: Mike Hunt, role: guest"
```

- сложные объекты
  - имеются ввиду объекты, поля которых являются массивами, объектами
  - в примере используется вложенная деструктуризация
  - фишка в том, что если не передать size и info и при этом у них не будет значения по умолчанию (`[ ]` и `{ }`), тогда при попытке их деструктурировать будет ошибка

```javascript
let settings = {  // <-- Сложный объект
  title: "Умные параметры",
  size: [400, 200],  // <-- У него поле является массивом
  info: {            // <-- И объектом
    year: 2007,
    duration: 93
  },
  items: ["Привет", "мир"]
};

// <-- Все поля заполнятся из-за деструктуризации объекта settings, поэтому ошибок не будет
foobar(settings);  

// <-- Все поля заполнятся за счет значений по умолчанию, поэтому тоже не будет ошибок
foobar();

function foobar({
  title = "Заголовок",
  size: [width = 300, height = 200] = [],  // <-- Задаем [] по умолч
  info: { year = null, duration = null } = {},  // <-- Задаем {} по умолч
  items = []
} = {}) {
  console.log(title);
  console.log(width + " " + height);
  console.log(year);
  console.log(duration);
  
  for (let item of items) {
    console.log(item);
  }
}
```

