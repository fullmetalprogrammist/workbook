---
title: "Принципы типизации"
layout: default
parent: "Типы TS"
nav_order: 100
---









# Структурная типизация

В TypeScript используется *структурная типизация*. Это означает, что типы считаются совместимыми, если у них совпадает набор свойств и методов (P.S. не забываем, что методы в JS - это тоже свойства, просто в них лежат функции).

Совпадение не подразумевает полную идентичность в наборе свойств. Имеется ввиду больше как пересечение. Т.е. в одном типе должны быть все свойства другого типа, +могут быть какие-нибудь уникальные.

Пример:

```typescript
interface Person {  // <-- У этого интерфейса два поля.
  firstname: string;
  lastname: string;
}

type Character = {  // <-- А у этого типа - три поля.
  firstname: string;
  lastname: string;
  age: number;
}

const characterTom: Character = {
  firstname: "Tom",
  lastname: "Sawyer",
  age: 13
}

const personHuck: Person = {
  firstname: "Huck",
  lastname: "Finn"
}

function printCharacter(character: Character) {
  console.log(`Hello, my name is ${character.firstname} ${character.lastname}!`);
  console.log(`I'm ${character.age} years old.`);
}

function printPerson(person: Person) {
  console.log(`Hello, my name is ${person.firstname} ${person.lastname}!`);
}

printPerson(characterTom);   // <-- Ok. Тип Character совместим с интерфейсом Person.
printCharacter(personHuck);  // <-- Ошибка! Person не совместим с Character, нет поля age.
```

Тип Character совместим с интерфейсом Person, потому что у него есть все свойства, которые есть в Person. А вот Person не совместим с Character, потому что у Person нет поля age.

В языках вроде C# используется *номинальная типизация* (nominal typing), там совместимость типов определяется их именем.



# Указания типа

* Тип указывается через двоеточие `:` после имени переменной или параметра функции.
* Для функции тип указывается после круглых скобок.

```typescript
let name: string;  // <-- Тип переменной - после имени переменной
name = "Tom Sawyer";
```

```typescript
// <-- Тип параметра - после имени параметра
function hello(name: string): void {  // <-- Тип функции - после круглых скобок
  console.log(`Hello, ${name}!`);
}
```

# Автоматическое определение типа

Компилятор может вычислить тип автоматически при присваивании переменной значения, поэтому в таких случаях можно не указывать тип:

```typescript
let name: string = "Tom Sawyer";  // <-- Можно в таких случаях не указывать тип
let name = "Tom Sawyer";  // <-- Тип string для name определится автоматически
```

```javascript
function hello(name: string): string {
  return `Hello, ${name}!`;
}

let message: string = hello("Tom");  // <-- Здесь тоже можно не указывать тип
let message = hello("Tom");  // <-- message будет типа string
```

Если не указать тип и при этом не присвоить значение, то тип будет any:

```typescript
let name;  // <-- Тип переменной name будет any
```