---
title: "type"
layout: default
parent: "TypeScript"
---

<h1>Оглавление</h1>

- TOC
{:toc}
# Описание нового типа

```typescript
type Person = {  // <-- Объявляем новый тип
  name: string,
  weight: number,
  height: number
};

const jack: Person = {  // <-- Создаем переменную этого типа
  name: "Jack",
  weight: 85,
  height: 180
};
```



# Создание псевдонима для типа

```typescript
type Kg = number;  // <-- Объявляем псевдонимы
type Cm = number;

let weigth: Kg = 85;  // <-- Пользуемся псевдонимами как типами
let height: Cm = 180;
```

Это может быть удобно для придания коду большей читабельности. В примере выше становится понятно, что вес выражен не просто числом, а килограммами. Использование псевдонима - все равно что использование оригинального типа, ничем не отличается.



# Методы в типе

Тип может содержать не только свойства, но и методы:

```typescript
type Person = {
  firstname: string;  // <-- Свойства
  lastname: string;
  fullname(): string;  // <-- И методы
  hello(): void;
};

const tom: Person = {
  firstname: "Tom",
  lastname: "Sawyer",
  fullname() {
    return `${this.firstname} ${this.lastname}`;
  },
  hello() {
    console.log(`Hello! My name is ${this.fullname()}`);
  }
};

tom.hello();
```

На практике type с методами встречается чуть реже, чем никогда, потому что type используется канонично для описания объектов с данными, но без поведения. Если объект содержит поведение - его стоит описывать через interface.



# Анонимные типы (inline types)

Чтобы указать идентификатору какой-то кастомный тип, не обязательно этот тип отдельно описывать и придумывать ему имя. Можно непосредственно описать его в нужном месте, так сказать, составить тип "на лету". 

Это называется анонимный тип (inline type):

```typescript
function printPoint(
      p: { x: number, y: number }  // <-- У параметра p объектный тип, без имени ("анонимный")
    ): void {
  console.log(`Точка (x: ${p.x}, y: ${p.y})`);
}

printPoint({ x: 5, y: 7 });  // Точка (x: 5, y: 7)
printPoint({ x: 5, y: 7, z: 10 });  // Ошибка: тип не сходится, у параметра p нет поля z
```

Аналогично для переменной можно описать кастомный тип прямо на месте:

```typescript
let user: {  // <-- Описываем тип прямо на месте.
    readonly firstName: string
  } = {
    firstName: 'abby'
  };
```

Анонимные типы хорошо подходят, когда тип надо указать разово и он не нужен в разных местах программы.


