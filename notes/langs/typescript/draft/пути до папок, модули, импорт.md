

- Ключевой вопрос
  - Понять "пути"

# Карта

- Проект ts + node.js (без бандлера)

  - Пути
    - Кейсы
      - Сижу пишу код в VS Code
      - Запустил локальный dev server через npm run dev
      - Задеплоил программу на реальный сервер (например, vercel)
    - Относительные
      - Используются по умолчанию
      - Относительность относительно файла, в котором используется import
    - Абсолютные
      - Надо настроить через tsconfig
        - baseUrl
          - Добавляется ко всем путям из paths
          - `./` означает директорию, в которой лежит tsconfig, обычно это корень проекта
        - paths
    - Пути во время написания кода
      - Когда пишем код в VS Code, в import'ах пишем пути, исходя из файловой системы проекта
        - VS Code проверяет правильность импортов с помощью TypeScript Language Service, для этого компиляция не нужна.
          - Этот же сервис проверяет и типы. Все это без компиляции.
  - Запущенная на Node программа
    - Когда мы запускаем файл foobar.js через node, то Node.js создает процесс и выполняет в нем наш foobar.js
    - Node.js в качестве текущей директории процесса устанавливает директорию, из которой был вызван node
      - Например, файл лежал в D:/my-progs/pet/heroes.js и мы запустили его node D:/my-progs/pet/heroes.js
        - "Текущая директория" процесса будет зависеть от того, где мы находились, когда вызвали node. Если были в D:/ то D:/ а если в D:/tmp то D:/tmp
        - [Эксперимент](#текущая-директория-процесса) для демонстрации текущей директории процесса
    - Точка входа в "программу" одна - это файл, который мы запускаем через node. Все остальные файлы загружаются через import в процессе работы
  - [dev server](#dev-server)
    - [npm run](#npm-run)
      - npm run 
  - Опции ts-компилятора rootDir и outDir
    - rootDir
      - Явно указываем компилятору, где в нашем проекте лежат исходные файлы программы
        - Зачем? (Перепроверить!!!) Иначе компилятор будет самостоятельно искать файлы и без бандлера при компиляции в выходной папке может оказаться лишнее, например, тесты.
      - ??? Настройка становится бесполезной при использовании бандлера?
    - outDir
      - Указываем, куда складывать скомпилированные файлы
        - Без этого они появятся рядом с исходными

  

## Мини-карта 1

- Node.js + без бандлера + программа это api на express
  - Запускаем через npm run dev из корня проекта
    - Текущей директорией `./` в файловых операциях становится корневая директория проекта



# dev server

- Два сценария
  - Наш проект - это например api на express.
    - В этом случае наша программа сама является сервером.
    - npm run dev запускает непосредственно нашу программу.
  - Наш проект - это frontend-приложение, например на React
    - В этом случае npm run dev запускает сборку, запускает dev-сервер и подсовывает ему нашу программу
- Варианты работы
  - Компиляция в памяти - скомпилированные файлы размещаются в RAM, а на диске не появляются
  - Обычная компиляция + запуск - файлы появляются на диске, потом программа запускается 
  - ??? nodemon

# Относительные и абсолютные пути

## Базовая информация о путях

- От чего отсчитываются
  - Относительный путь
    - Если используется в импортах
      - Отсчитывается относительно файла, в котором использован импорт
    - Если используется в файловых операциях
      - Отсчитывается относительно текущей директории процесса (cwd)
  - Абсолютный путь
    - От корня файловой системы



# npm run

package.json

```yaml
"scripts": {
  "dev": "nodemon -r tsconfig-paths/register src/server.ts"
},
```

- npm run dev
  - npm run нужен для запуска скриптов из package.json
  - npm run передает директорию, из которой он запущен, в Node и она становится текущей директорией для процесса, который запускает Node
    - npm команды всегда запускаются из корня проекта, это золотое правило
  - На практике это означает следующее
    - Например проект лежит в E:\pet-projs\herodiff\herodiff-api
    - Мы переходим в эту директорию cd E:\pet-projs\herodiff\herodiff-api и запускаем npm run dev
    - npm run передает директорию E:\pet-projs\herodiff\herodiff-api в Node
    - Node запускает процесс, в котором выполняется наша программа, и текущей директорией этого процесса считается E:\pet-projs\herodiff\herodiff-api

# Текущая директория процесса

Цель: понять чему равна "текущая директория процесса", запущенного на Node.

Создаем скрипт foobar.js:

```javascript
console.log("process.cwd() : " + process.cwd());
console.log("__dirname : " + __dirname);
```

Кладем его в `D:/tmp/experiment/foobar.js`

- Эксперимент 1

  ```
  D:\>node D:/tmp/experiment/foobar.js    # Находимся в D: используем абсолютный путь
  
  process.cwd() : D:\
  __dirname : D:\tmp\experiment
  ```

  ```
  D:\>node ./tmp/experiment/foobar.js    # Находимся в D: используем относительный путь
  
  process.cwd() : D:\
  __dirname : D:\tmp\experiment
  ```

- Эксперимент 2

  ```
  D:\tmp>node D:/tmp/experiment/foobar.js    # Находимся в D:\tmp используем абсолютный путь
  
  process.cwd() : D:\tmp
  __dirname : D:\tmp\experiment
  ```

  ```
  D:\tmp>node ../tmp/experiment/foobar.js    # Находимся в D:\tmp используем относительный путь
  
  process.cwd() : D:\tmp
  __dirname : D:\tmp\experiment
  ```

Выводы из экспериментов:

- Текущая директория процесса (cwd) - это директория, из которой вызван node.
  - Директория, в которой лежит программа, в этом случае не важна. 
  - Как указан путь до программы - абсолютным путем или относительным - не важно.
  - Т.е. если мы находимся в D:/tmp и вызываем node experiment/foobar.js, то cwd будет D:/tmp а если находимся в D:/ то cwd будет D:/
- __dirname указывает на директорию, в которой лежит запущенный файл.
  - На __dirname не влияет, откуда запущена программа.



# Импорты, пути

## Относительные и абсолютные пути

При создании чистого ts-проекта, в конфиге не настроены пути. Это значит, что все импорты надо писать относительными путями - относительного файла, в котором используется импорт:

```typescript
import { foo } from '../../bar/qwerty';  // <-- Относительный путь
```

Чтобы использовать абсолютные пути, надо в конфиге (tsconfig.json) указать `baseUrl` и `paths`:

```yaml
"baseUrl": "./",
"paths": {
  "@/*": ["./*"],
  "@src/*": ["src/*"],
  "@controller/*": ["src/controller/*"],
  "@service/*": ["src/service/*"]
}
```

Теперь можно писать

```typescript
import { foo } from "@src/bar/lol/kek"  // <-- Абсолютный путь
import { foo } from "@/src/bar/lol/kek"
```

## Связь между baseUrl и paths

baseUrl `./` означает отсчет от директории, где лежит tsconfig.json, т.е. обычно это корень проекта.

```typescript
import { foo } from '@src/bar/qwerty';
```

baseUrl добавляется ко всем путям из paths, т.е.

```
./                -->  ././ автоматически нормализуется и становится просто ./
src/*             -->  ./src/*
src/controller/*  -->  ./src/controller/*
src/service/*     -->  ./src/service/*
```

Когда мы пишем import в VS Code, то должны ориентироваться по файловой системе своего проекта. В этот момент нет никакой связи с запущенной программой, например, на dev server.











# Draft

## rootDir, outDir и бандлер

### rootDir

- `rootDir` это опция компилятора, которая задает директорию, в которой лежат исходные файлы проекта. 
  - ???Файлы вне этой директории игнорируются
  - Что будет если не указать rootDir?
    - Без этой опции компилятор сам пытается вычислить корневую директорию самостоятельно.
      -  Как?
- outDir
  - зачем нужна эта опция?
  - что будет если не указать?
    - ??? Скомпилированные файлы компилятор положит рядом с исходными.
- Как эти опции связаны с бандлером?
  - Нужны ли они, если используется бандлер?