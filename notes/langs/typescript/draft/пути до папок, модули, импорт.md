<h1>Оглавление</h1>

- TOC
{:toc}






# Карта

- Пути
  - [Относительный и абсолютный](#относительные-и-абсолютные-пути)
    - Корень `/` и текущее положение `./`
  - Суть в том, что в моменте надо осознавать:
    - Что сейчас является корнем, а что - текущим положением. Для этого надо:
      - Прочитать [текущая директория и корень](#текущая-директория-и-корень), чтобы понимать чему равна текущая директория и корень в программе, выполняющейся на Node
      - Прочитать [npm run](#npm-run), чтобы понимать, как запуск через npm влияет на текущую директорию работающей на Node программы
    - Где написан путь - в import, в файловой операции, в fetch и т.д., т.к. это разные ситуации и понятие корня и текущего положения для них отличаются
      - import
        - Ориентируемся по файловой структуре своего проекта. `./` отсчитывается от директории, где лежит файл в котором мы используем import. Использовать `/` не следует, потому что это будет путь в реальной файловой системе нашего компьютера и если например перенести проект в другую папку, все сломается и тем более это не будет работать при публикации на сервере.
          - Вместо относительных путей лучше использовать [алиасы путей, пакет tsconfig-paths](#алиасы-путей-пакет-tsconfig-paths)
      - Файловая операция
        - Выполняется в рантайме, поэтому ориентируемся исходя из `./` процесса
      - fetch
        - `./` TODO
        - `/` TODO

  



# Карта черновик

- Проект ts + node.js (без бандлера)

  - Пути
    - Кейсы
      - Сижу пишу код в VS Code
      - Запустил локальный dev server через npm run dev
      - Задеплоил программу на реальный сервер (например, vercel)
  - Опции ts-компилятора rootDir и outDir
    - rootDir
      - Явно указываем компилятору, где в нашем проекте лежат исходные файлы программы
        - Зачем? (Перепроверить!!!) Иначе компилятор будет самостоятельно искать файлы и без бандлера при компиляции в выходной папке может оказаться лишнее, например, тесты.
      - ??? Настройка становится бесполезной при использовании бандлера?
    - outDir
      - Указываем, куда складывать скомпилированные файлы
        - Без этого они появятся рядом с исходными
  
  

## Мини-карта 1

- Node.js + без бандлера + программа это api на express
  - Запускаем через npm run dev из корня проекта
    - Текущей директорией `./` в файловых операциях становится корневая директория проекта





# import

- Когда пишем код в VS Code, в import'ах пишем пути, исходя из файловой системы проекта
  - VS Code проверяет правильность импортов с помощью TypeScript Language Service, для этого компиляция не нужна.
    - Этот же сервис проверяет и типы. Все это без компиляции.
- import происходит в рантайме - TODO



# dev server

## Формат работы в зависимости от типа проекта

- Наш проект - это например api на express.
  - В этом случае никакого dev сервера по сути нет
  - В npm run dev мы пишем запуск непосредственно нашей программы
- Наш проект - это frontend-приложение, например на React
  - В этом случае есть dev сервер, который принимает запросы и переадресовывает их нашему приложению
  - npm run dev запускает сборку, запускает dev-сервер и через него мы получаем доступ к своей программе

## Варианты работы

- Компиляция в памяти - скомпилированные файлы размещаются в RAM, а на диске не появляются
- Обычная компиляция + запуск - файлы появляются на диске, потом программа запускается 
- ??? nodemon

## черновик

- Грубо скажем, что у любого сервера есть корень. В линуксе например это `/`
- Абсолютный путь считается от этого корня
- У dev сервера тоже есть корень
  - Обычно это корневая директория проекта, для которого запускается dev сервер
  - Например, перешли в D:/my-progs/pets/herodiff, запустили npm run dev, и корнем dev сервера стала директория D:/my-progs/pets/herodiff

# Относительные и абсолютные пути

- Виды путей
  - Абсолютный
    - Это всегда путь от корня `/`
  - Относительный
    - Это всегда путь от текущего положения `./`
    - Пути `./tmp/heroes` и `tmp/heroes` это одно и то же
      - Просто в первом нагляднее видно что это относительный путь от текущей директории







# Текущая директория и корень

Цели:

- Понять, чему равна "текущая директория" `./` в процессе, запущенном на Node.
- Чему равен "корень" `/` 

Создаем скрипт foobar.js:

```javascript
const path = require('path');

console.log("process.cwd() : " + process.cwd());
console.log("__dirname     : " + __dirname);
console.log("./ : " + path.resolve("./"));
console.log("/  : " + path.resolve("/"));
```

- Кладем его в `D:/tmp/experiment/foobar.js`
- Переходим в `cd D:/tmp`

Проверяем:

```
D:\tmp>node experiment/foobar.js    # Находимся в D:/tmp используем абсолютный путь

process.cwd() : D:\tmp
__dirname     : D:\tmp\experiment
./ : D:\tmp
/  : D:\
```

```
D:\tmp>node ./experiment/foobar.js    # Находимся в D:/tmp используем относительный путь

process.cwd() : D:\tmp
__dirname     : D:\tmp\experiment
./ : D:\tmp
/  : D:\
```

Выводы из экспериментов:

- Текущая директория процесса (cwd) - это директория, из которой процесс запущен через node.
  - Директория, в которой лежит программа, в этом случае не важна. 
  - Как указан путь до программы - абсолютным путем или относительным - не важно.
  - Т.е. если мы находимся в D:/tmp и вызываем node experiment/foobar.js, то cwd будет D:/tmp а если находимся в D:/ то cwd будет D:/
- __dirname указывает на директорию, в которой лежит запущенный файл.
  - На __dirname не влияет, откуда запущена программа.
- "Текущая директория" (`./`) - это cwd
- "Корень" (`/`) - это корень файловой системы
  - В винде как видно из примера это диск D:/
  - В линуксе это был бы самый корень файловой системы /



# npm run

package.json

```yaml
"scripts": {
  "dev": "nodemon -r tsconfig-paths/register src/server.ts"
},
```

- npm run dev
  - npm run нужен для запуска скриптов из package.json
  - npm run передает директорию, из которой он запущен, в Node и она становится текущей директорией для процесса, который запускает Node
    - npm команды всегда запускаются из корня проекта, это золотое правило
  - На практике это означает следующее
    - Например проект лежит в E:\pet-projs\herodiff\herodiff-api
    - Этот проект - api на express, точка входа E:\pet-projs\herodiff\herodiff-api\src\server.ts
    - Мы переходим в директорию cd E:\pet-projs\herodiff\herodiff-api и запускаем npm run dev
    - npm run передает директорию E:\pet-projs\herodiff\herodiff-api в Node
    - Node запускает процесс, в котором выполняется наша программа, и текущей директорией этого процесса считается E:\pet-projs\herodiff\herodiff-api
    - Вывод: когда запускаешь что-то через npm run, `./` указывает на корень проекта

```
process.cwd() : E:\pet-projs\herodiff\herodiff-api
__dirname : E:\pet-projs\herodiff\herodiff-api\src
./ : E:\pet-projs\herodiff\herodiff-api
/  : E:\
```





# Vercel

- Я заливаю свою программу на vercel
- Программа начинает работать не сразу, а только когда к ней приходит первый запрос
- Поднимается контейнер (cold start), в котором крутится Node.js и выполняет мою программу
  - В контейнере своя файловая система
- Пока к приложению обращаются, контейнер живет
  - Когда приложение начинает простаивать (точное время не известно), контейнер дропается
    - Все, чтобы было в его файловой системе, при этом уничтожается
    - Если нужно сохранить информацию между дропами контейнера, нужна база данных
  - При повторном обращении к приложению контейнер поднимается заново







# Алиасы путей, пакет tsconfig-paths

При создании чистого ts-проекта, в конфиге не настроены пути. Это значит, что все импорты надо писать относительными путями - относительного файла, в котором используется импорт:

```typescript
import { foo } from '../../bar/qwerty';  // <-- Относительный путь
```

Чтобы использовать абсолютные пути, надо в конфиге (tsconfig.json) указать `baseUrl` и `paths`:

```yaml
"baseUrl": "./",
"paths": {
  "@/*": ["./*"],
  "@src/*": ["src/*"],
  "@controller/*": ["src/controller/*"],
  "@service/*": ["src/service/*"]
}
```

Теперь можно писать

```typescript
import { foo } from "@src/bar/lol/kek"  // <-- Абсолютный путь
import { foo } from "@/src/bar/lol/kek"
```

## Связь между baseUrl и paths

baseUrl `./` означает отсчет от директории, где лежит tsconfig.json, т.е. обычно это корень проекта.

```typescript
import { foo } from '@src/bar/qwerty';
```

baseUrl добавляется ко всем путям из paths, т.е.

```
./                -->  ././ автоматически нормализуется и становится просто ./
src/*             -->  ./src/*
src/controller/*  -->  ./src/controller/*
src/service/*     -->  ./src/service/*
```

Когда мы пишем import в VS Code, то должны ориентироваться по файловой системе своего проекта. В этот момент нет никакой связи с запущенной программой, например, на dev server.











# Draft

## rootDir, outDir и бандлер

### rootDir

- `rootDir` это опция компилятора, которая задает директорию, в которой лежат исходные файлы проекта. 
  - ???Файлы вне этой директории игнорируются
  - Что будет если не указать rootDir?
    - Без этой опции компилятор сам пытается вычислить корневую директорию самостоятельно.
      -  Как?
- outDir
  - зачем нужна эта опция?
  - что будет если не указать?
    - ??? Скомпилированные файлы компилятор положит рядом с исходными.
- Как эти опции связаны с бандлером?
  - Нужны ли они, если используется бандлер?



- - 