---
title: "Redux Toolkit"
layout: default
parent: "Фреймворки"
---


<h1>Оглавление</h1>
- TOC
{:toc}


# Redux vs Redux Toolkit (RTK)

- Redux - это исходная версия библиотеки, чистый, "ванильный" редакс
- Redux Toolkit (RTK) - это надстройка над ванильным редаксом, в которой сокращено количество бойлерплейта
  - Все типичные паттерны использования Redux нашли воплощение в RTK
- В данный момент в ходу RTK
  - Даже разработчики библиотеки рекомендуют использовать RTK, а не ванильный редакс
- Так что это не две конкурирующие технологии, а по сути одно и то же
- Суть использования редакса
  - Вынести общее состояние в отдельный объект и предоставить всем компонентам удобный доступ к нему
  - Общее состояние - это то, которое может понадобиться компонентам на разных уровнях вложенности - как самым высоким, так и очень глубоко вложенным
  - Для того, чтобы не пришлось прокидывать это состояние сквозь десятки компонентов через пропсы, и существует редакс
  - При этом у компонентов может быть и свое локальное состояние
    - Если вдруг оно не нужно никому, кроме самого компонента и пары его дочек, то нет смысла выносить его в общее хранилище



# Базовый флоу работы с редаксом

- [Придумать структуру состояния](#состояние)
  - Придумать начальное значение состояния \ фрагментов состояния
- [Придумать действия над состоянием \ фрагментами](#действия-action-и-action-creator)
  - Написать action creator'ы под эти действия
    - В ванильном Redux - руками
    - [В RTK - помогут слайсы](#слайс)
- [Создать редюсеры](#редюсер)
  - Привязать к ним начальные состояния
  - Запрограммировать редюсеры для реакции на нужные действия
    - В ванильном Redux - руками
    - [В RTK - помогут слайсы](#слайс)
- [Объединить редюсеры в корневой редюсер](#корневой-редюсер)
- [Создать хранилище](#хранилище)
  - Передать корневой редюсер в хранилище (обычно при создании)
  - Опциональные действия
    - Подключение middleware (devtools, асинхронные действия и т.д.)
- Обернуть приложение хранилищем
- [Подписать компоненты приложения на нужные данные через useSelector](#чтение)
- [Раскидать по компонентам dispatch действий для записи в хранилище](#запись)

# Базовые концепции

## Состояние

- ⭐ [Состояние](базовые-концепции#состояние-и-фрагменты-состояния) - это все данные целиком, которые находятся в хранилище
  - Например состояние "Досье", которое включает в себя довольно много информации о человеке
- Фрагмент состояния
  - Это "кусочек состояния", из таких кусочков собирается целиковое состояние
    - Например
      - "Персональная информация" - ФИО + дата рождения
      - "Контакты" - телефон + почта + адрес
      - "Семья" - мать + отец + братья + сестры + жены + дети
      - "Стаж" - массив мест работы
      - etc
    - Сложи все эти кусочки - получишь целостное "состояние"

## Работа с состоянием

- Состояние очевидно существует для того чтобы его читать \ изменять

### Действия (action) и action creator

- ⭐ [Действия (action)](базовые-концепции#действие)
  - Это объекты, олицетворяющие доступные над состоянием операции
    - Например
      - Изменить персональную информацию (поменять фамилию \ имя)
      - Добавить место работы
      - Удалить телефон
      - etc
- Состав действия
  - Тип действия
    - Идентификатор, который однозначно отличает одно действие от другого
      - Обычно это просто строка, например "changePersonalInfo", "deletePhone", "addWorkCompany"
      - Соглашения по именованию
        - Формат `domain/ACTION_NAME`
          - Домен в данном случае это синоним фрагмента состояния, например `person/UPDATE_FIRSTNAME`
  - Нагрузка
    - Это данные, которые связаны с этим действием
      - Например
        - Действие "Изменить персональную информацию"
          - Нагрузка - объект { новое ФИО + дата рождения }
          - Можно было бы сделать отдельных 4 действия на изменение отдельно имени, отчества, фамилии, даты рождения. Тогда бы в нагрузках этих действий были бы, соответственно, только имя, отчество, фамилия, дата рождения по-отдельности
- ⭐ [Action Creator ("конструктор действия")](базовые-концепции#action-creator)
  - Это функция, которая упрощает создание корректного объекта действия
    - За счет чего она упрощает
      - В ней устанавливается тип действия, так что не приходится писать его руками
    - Функция должна быть чистой, никаких побочных эффектов
  - Итого, action creator принимает данные для нагрузки и возвращает готовый объект действия
    - Данные лучше передавать единственным значением - примитив или объект
      - Не надо передавать например имя и фамилию двумя параметрами, и собирать из них объект нагрузки внутри AC, лучше собрать объект снаружи и передать в AC готовый
      - Основная задача AC - это устранить путаницу с типом действия
        - Поэтому все остальное - сборка, трансформация данных, валидация - не его ответственность

### Редюсер

- ⭐ [Редюсер](базовые-концепции#редюсер)
  - Это функция, которая принимает два аргумента
    - Состояние
      - ⚡ Через значение по умолчанию мы указываем стартовое, "исходное" значение для состояния
    - Действие
  - Обычно, если состояние состоит из фрагментов, то на каждый фрагмент есть свой редюсер
    - Тогда он принимает *фрагмент* состояния + действие
      - Дальше буду просто писать "состояние", имея ввиду что это может быть также и фрагмент
  - Смысл редюсера
    - Это функция для изменения состояния
    - Он содержит логику для обработки одного или нескольких действий
      - Например, если действие "изменить фамилию", тогда логика будет "взять старое имя, старое отчество, старую дату рождения, а фамилию взять новую"
  - Редюсер проверяет тип действия и понимает, должен ли он его обрабатывать или нет
    - Если должен - то берет текущее состояние, берет данные из нагрузки; согласно своей логике формирует новую версию состояния и возвращает ее как результат своей работы
    - Если не должен - возвращает состояние без изменений
    - ⚡ Состояние остается иммутабельным - оно не **из**меняется, а **за**меняется новой версией
  - Редюсеры напрямую мы не вызываем
    - Мы их просто описываем и отдаем редаксу (обычно при создании хранилища)
    - Мы передаем действие диспетчеру, и редакс сам прогоняет его через редюсеры

### Корневой редюсер

- ⭐ [Корневой редюсер (root reducer)](базовые-концепции#корневой-редюсер)
  - Более техническая концепция
  - Объект, который включает в себя все редюсеры
    - И обычно тут же мы задаем, под каким именем в итоговое состояние попадет фрагмент
      - `person: pReducer` - фрагмент, за который отвечает pReducer, окажется в состоянии в поле person
  - Redux использует корневой редюсер, чтобы инициализировать состояние
    - Как это происходит
      - Он прокидывает в каждый редюсер фейковое действие
      - Редюсеры видят, что они не должны обрабатывать это действие, и просто возвращают свой фрагмент состояния без изменений
      - Redux из этих фрагментов собирает целостное состояние
  - В Redux и RTK корневой редюсер настраивается по-разному

## Вспомогательные вещи

### Слайс

- ⭐ [Слайс (slice)](базовые-концепции#слайсы)
  - Концепция из RTK
  - Это объект, в котором мы описываем
    - Начальное состояние
    - Функции для обработки действий
      - Из этих функций слайс потом автоматически собирает редюсер
  - На каждый фрагмент состояния - свой слайс
  - Смысл слайса
    - Упростить рутинные вещи
      - Создаст за нас action creator'ы
      - Соберет редюсер из функций обработки действий, которые мы в слайсе описали
        - Благодаря этому нам не придется руками писать `switch(action.type)`
  - Особенности слайсов
    - В редюсерах внутри слайса мы можем изменять состояние в мутирующем стиле
      - Потому что по умолчанию в RTK используется библиотека Immer и все мутации она трансформирует в создание нового объекта. Со стороны кажется что мы мутируем (так удобнее писать), а внутри на самом деле нет мутации исходного объекта, а создается новый

## Хранилище

- ⭐ Хранилище (store)

### Создание хранилища

- [Создаем инстанс хранилища](базовые-концепции#создание-хранилища)
  - Начальная настройка
    - Обычно при создании хранилища нужно передать в него корневой редюсер
    - middleware - TODO
- Оборачиваем приложение в компонент-провайдер, и за счет контекста состояние становится доступно всем компонентам приложения

### Запись

- ⭐ Функция-диспетчер
  - Получаем ее через хук `useDispatch`
- Передаем действие в диспетчер
- Редакс пробрасывает это действие через все редюсеры, получается новое состояние
- Компоненты, которые пользуются состоянием (**подписчики**), получают актуальное значение состояния

### Чтение

- ⭐ Подписчик
  - Если компоненту нужны данные из хранилища, он получает их через хук `useSelector`
    - `const firstname = useSelector(state => state.person.firstname);`
      - Тут подписчику нужно только имя
  - Используя useSelector, он
    - Получает актуальные данные из хранилища
    - *Подписывается* на их изменения
      - Если конкретно эти данные изменятся, подписчик отрендерится повторно, получив т.о. актуальные данные
        - "Конкретно эти" означает те, которые выбраны в селекторе
          - Например, если изменился state.person.firstname, то это повторный рендер, а если изменился state.person.lastname, то нет, т.к. в селекторе выбран только firstname
          - Поэтому надо грамотно составлять селекторы, выбирая только реально нужные компоненту поля, чтобы избежать лишних рендеров
      - Определение, изменились ли данные, в которых заинтересован подписчик, происходит внутри useSelector
        - Через строгое сравнение `===`

# Продвинутые концепции

## Thunk (танки)



# Практические рекомендации

## Состояние

- Структура состояния
  - Делать структуру как можно более плоской, без лишней вложенности

## Action creator

- Не делать валидацию, трансформацию данных в AC

## Редюсеры

- Изменять фрагмент целиком или частями?
  - Т.е. делать отдельные действия для изменения имени, фамилии, отчества, даты рождения, или в одном действии разом перезаписать весь фрагмент?
    - Это вопрос производительности
      - Лишних рендеров мы избегаем за счет грамотного указания в useSelector только нужных компоненту полей
      - Вопрос сводится к тому, вызвать два-три раза dispatch это более накладно, чем один раз?
        - Ответ: да, это накладнее (хотя может быть и не очень сильно), потому что каждый вызов - это прогон действия по всем редюсерам
        - Что делать? Можно сделать и отдельные действия для каждого поля, и общее действие для обновления всех полей (или их комбинации, например, имя+фамилия)
          - Т.о. мы получим возможность точечно изменять фрагмент, и разом менять несколько полей за одно действие, если это надо