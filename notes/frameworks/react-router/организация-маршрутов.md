---
title: "Организация маршрутов"
layout: default
parent: "React Router"
nav_order: 100
---

<h1>Оглавление</h1>

- TOC
{:toc}




# Пример описания маршрутов

```jsx
createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <BrowserRouter>  {/* <-- Все приложение оборачиваем в маршрутизатор */}
      <Routes>
        <Route path="/" element={<App />} />
        <Route path="/konspekt/*" element={<NoteView />} />
      </Routes>
    </BrowserRouter>
  </StrictMode>,
)
```





# Механика работы маршрутизации

- В SPA нет реального перехода между страницами
  - На "обычном сайте" щелчок по ссылке приводит к обращению на сервер для загрузки другой страницы
  - В SPA страница всегда одна, поэтому они и называются одностраничными. "Перейти на другую страницу" в SPA фактически означает просто программно отрисовать другой компонент на той же самой странице
- BrowserRouter отслеживает изменения URL 
  - URL хранится в состоянии BrowserRouter
  - URL изменяется - изменяется состояние BrowserRouter > происходит повторный рендеринг BrowserRouter и вложенных в него компонентов
  - Компонент Routes анализирует URL и определяет компонент, который с этим URL связан
  - Реакт отрисовывает этот компонент







# Всегда главная страница

При использовании BrowserRouter надо настроить веб-сервер так, чтобы он на любой запрос возвращал главную страницу приложения. Приложение само определит по URL, какую страницу надо отрисовать.

Если такую настройку не сделать, то сервер будет сам пытаться обработать URL и мы будем получать 404 ошибку, потому что в одностраничных приложениях только одна физически реальная страница и у сервера ничего другого просто нет.

- В dev-сервере webpack'а такая настройка выполняется через опцию `historyApiFallback: true`.
- В dev-сервере Vite настраивать это не надо, оно уже по умолчанию так настроено.



# Компонент BrowserRouter

- Исходники

  - BrowserRouter

    - https://github.com/remix-run/react-router/blob/3e3a223ee90c1fee3da01daf6866ad2f5bdf62ba/packages/react-router/lib/dom/lib.tsx#L902

  - Router

    - https://github.com/remix-run/react-router/blob/3e3a223ee90c1fee3da01daf6866ad2f5bdf62ba/packages/react-router/lib/components.tsx#L1259

    

## basename, "программа в подпапке"

- Кейс - публикация приложения на github pages
  - Приложение будет доступно по адресу вида `https://vasyapupkin.github.io/awesomeapp/`
    - имя пользователя + **имя репозитория**
  - Т.е. обращаться надо к ориджин + дополнительный path (``https://vasyapupkin.github.io` + `awesomeapp`)
    - В то время как локально обращение идет просто через ориджин, например `http://localhost:5173/`
    - Плюс при публикации на других сервисах тоже может не требоваться дополнительный path
  - Поэтому менять структуру проекта не хочется

Решение: использовать пропс basename у BrowserRouter:

```jsx
<BrowserRouter basename={import.meta.env.VITE_BASE_PATH}>
  <Routes>
    <Route path="/" element={<App />} />
    <Route path="/konspekt/*" element={<NoteView />} />
  </Routes>
</BrowserRouter>
```

```yaml
# файл .env.development
VITE_BASE_PATH=/
# файл .env.production
VITE_BASE_PATH=/awesomeapp
```

Объяснение:

- Используем переменные окружения для задания basename
  - При сборке подставится значение дополнительного path
  - При локальном запуске подставится просто /
- Можно было бы использовать условие, но через переменные окружения каноничнее

Вопрос:

- Почему бы просто не использовать `./` в basename?
  - Ответ
    - basename в данном случае НЕ РЕЗОЛВИТСЯ, он остается просто строкой `./`
      - Т.е. при переходе на `https://vasyapupkin.github.io/awesomeapp/` ./ так и останется ./
      - Вот если бы это было не реакт приложение, а обычная страница, тогда ./ в скрипте бы резолвился в `https://vasyapupkin.github.io/awesomeapp/`. Но у нас не обычная страница.
    - Поэтому шаблон не совпадет с URL роутер не сможет понять, какой компонент рендерить
    - P.S. TODO Как именно все это работает (то ли из url вычитается ориджин и basepath, то ли наборот basepath приклеивается к шаблонм) можно посмотреть в исходниках, я нашел их и оставил ссылки  выше, но конкретно сейчас нет времени этим заниматься. Концептуально описал почему проблема, а технически как это работает как будто бы и пофиг.







# Компонент Routes

Компонент `Routes` нужен для того, чтобы определить по текущему URL, какой компонент надо отрисовать. Routes группирует в себе компоненты `Route`, которые содержат информацию, какой URL с каким компонентом связан.

Когда URL изменяется, этот факт отлавливает BrowserRouter и происходит повторный рендеринг. Соответственно, при повторном рендеринге у Routes есть доступ к обновленному URL, так что он проверяет вложенные в себя Route и определяет компонент, который нужно отрисовать.



# Компонент Route

Описывает маршрут

- path проп - адрес маршрута
  - Задаем шаблон маршрута
- element проп - какой компонент отображать







# Динамический маршрут

Динамический маршрут - это маршрут, в котором есть изменяющийся параметр, например:

```
www.foobar.com/notes/7
```

где 7 - id заметки и он изменяется в зависимости от того, какую заметку нужно открыть.

## Организация динамического маршрута

Работа с динамическими маршрутами строится примерно так:

* В компоненте `<Route>` через атрибут path задаем путь с изменяющимся параметром:

  ```react
  <Route path='/notes/:id' element={<Note />} />
  ```

  Изменяющийся параметр отделяем двоеточием `:`

* Организуем переходы. Как именно - не важно, можно через компонент Link, можно через хук useNavigate. Главное правильно формировать ссылки.

* Создаем компонент для динамического маршрута. В нем с помощью хука `useParams` можем извлечь значение динамического параметра из url.

  * Параметр будет называться так же, как он описан в Route. Например, если там `/notes/:id`, то и при извлечении к нему надо обращаться как `id`

    ```javascript
    const params = useParams();  // <-- Получаем параметры из url
    const id = params.id;
    ```

    

## Пример

```react
import { BrowserRouter } from 'react-router-dom';
import { Routes, Route } from 'react-router-dom';
import { useNavigate } from 'react-router-dom';
import { useParams } from 'react-router-dom';

export default function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path='/notes' element={<Notes />} />
        <Route path='/notes/:id' element={<Note />} />  {/* <-- Динамический маршрут */}
      </Routes>
    </BrowserRouter>
  );
}

// <-- Компонент со списком заметок
function Notes() {
  const notes = [...Array(10)].map((_, i) => { return { 
      id: i + 1, 
      short: `Заметка #${i + 1}`
    }
  });

  const navigate = useNavigate();
  const read = (id) => navigate(`/notes/${id}`);  // <-- Реализация перехода через useNavigate.

  return (
    <>
      <h1>Страница со списком заметок</h1>
      {
        notes.map(n => <div>{n.short}
            <Link to={`/notes/${n.id}`}>Читать</Link> {/* Реализация перехода через Link */}
            <button onClick={() => read(n.id)}>Читать</button>
          </div>
        )
      }
    </>
  );
}

// <-- Компонент конкретной заметки
function Note() {
  const params = useParams();  // <-- Получаем параметры из url
  // <-- Используем параметры для дальнейших действий
  return <h1>Страница заметки #{params.id}</h1>
}
```





# Вынос маршрутов из кода

Можно оформить маршруты в виде, например, массива и вынести его в отдельный файл. Так будет проще их редактировать:

```javascript
import { Glagne, About, Store } from './pages.js';

export const routes = [
  { 
    path: '/', 
    element: <Glagne /> 
  },
  { 
    path: '/about', 
    element: <About /> 
  },
  { 
    path: '/store',
    element: <Store />
  },
];

```

Все страницы для простоты оформлены в единственном файле `pages.js`:

```react
export function Glagne() {
  return <h1>Это стартовая страница приложения</h1>
}

export function About() {
  return <h1>Здесь можно почитать о приложении</h1>
}

export function Store() {
  return <h1>Ознакомьтесь с нашими услугами</h1>
}
```

Компонент приложения:

```react
import { BrowserRouter } from 'react-router-dom';
import { Routes, Route } from 'react-router-dom';
import { Link } from 'react-router-dom';
import { routes } from './routes';

export default function App() {
  return (
    <BrowserRouter>
      <Menu />
      <Routes>
        {/* Отрисовываем маршруты на основе массива */}
        { routes.map(r => <Route path={r.path} element={r.element} />) }
      </Routes>
    </BrowserRouter>
  );
}

// <-- Компонент навигационной панели
function Menu() {
  return (
    <div style={{ display: 'flex', columnGap: '5rem' }}>
      <Link to='/'>На главную</Link>
      <Link to='/about'>О приложении</Link>
      <Link to='/store'>Магазин</Link>
    </div>
  )
}
```



# Публичные и приватные маршруты

Тут скорее просто заглушка для будущих исследований, потому что описанный способ выглядит так себе.

```react
import { BrowserRouter } from 'react-router-dom';
import { Routes, Route } from 'react-router-dom';
import { Link } from 'react-router-dom';

export default function App() {
  const isAuth = false;
  const printRoutes = isAuth ? routes : routes.filter(r => r.access === 'public');
  return (
    <BrowserRouter>
      <Menu />
      <Routes>
        { printRoutes.map(r => <Route path={r.path} element={r.element} />) }
      </Routes>
    </BrowserRouter>
  );
}

// <-- Коллекция маршрутов
export const routes = [
  { 
    path: '/', 
    element: <Glagne />,
    access: 'public'
  },
  { 
    path: '/about', 
    element: <About />,
    access: 'public'
  },
  { 
    path: '/store',
    element: <Store />,
    access: 'private'
  },
];


// <-- Компонент навигационной панели
function Menu() {
  return (
    <div style={{ display: 'flex', columnGap: '5rem' }}>
      <Link to='/'>На главную</Link>
      <Link to='/about'>О приложении</Link>
      <Link to='/store'>Магазин</Link>
    </div>
  )
}

// <-- Компоненты страниц
export function Glagne() {
  return <h1>Это стартовая страница приложения</h1>
}

export function About() {
  return <h1>Здесь можно почитать о приложении</h1>
}

export function Store() {
  return <h1>Ознакомьтесь с нашими услугами</h1>
}
```

