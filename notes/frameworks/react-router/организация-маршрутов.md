---
title: "Организация маршрутов"
layout: default
parent: "React Router"
nav_order: 100
---

<h1>Оглавление</h1>

- TOC
{:toc}




# Пример описания маршрутов

```jsx
createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <BrowserRouter>  {/* <-- Все приложение оборачиваем в маршрутизатор */}
      <Routes>
        <Route path="/" element={<App />} />
        <Route path="/konspekt/*" element={<NoteView />} />
      </Routes>
    </BrowserRouter>
  </StrictMode>,
)
```





# Механика работы маршрутизации

- В SPA нет реального перехода между страницами
  - На "обычном сайте" щелчок по ссылке приводит к обращению на сервер для загрузки другой страницы
  - В SPA страница всегда одна, поэтому они и называются одностраничными. "Перейти на другую страницу" в SPA фактически означает просто программно отрисовать другой компонент на той же самой странице
- BrowserRouter отслеживает изменения URL 
  - URL хранится в состоянии BrowserRouter
  - URL изменяется - изменяется состояние BrowserRouter > происходит повторный рендеринг BrowserRouter и вложенных в него компонентов
  - Компонент Routes анализирует обновленный URL и определяет компонент, который с этим URL связан
  - Реакт отрисовывает этот компонент



# Компонент BrowserRouter

Компонент BrowserRouter

- basename проп
  - Является примитивом - строкой
  - Приделывается к path из Route
- BR не резолвит пути, просто склеивает строки, поэтому например `./` не работает, т.к. ./ не резолвится, а остается строкой
- ❓ Сервер всегда должен возвращать главную страницу



## basename, "программа в подпапке"



## Всегда главная страница

При использовании BrowserRouter мы должны настроить веб-сервер так, чтобы он на любой запрос возвращал главную страницу приложения. Приложение само определит по URL, какую страницу надо отрисовать. Если такую настройку не сделать, то сервер будет сам пытаться обработать URL и мы будем получать 404 ошибку, потому что в одностраничных приложениях только одна физически реальная страница и у сервера ничего другого просто нет.

В dev-сервер такая настройка выполняется через опцию `historyApiFallback: true`. В конспекте о dev-сервере об этом написано.





## Компонент Routes

Компонент `Routes` нужен для того, чтобы определить по текущему URL, какой компонент надо отрисовать. Routes группирует в себе компоненты `Route`, которые содержат информацию, какой URL с каким компонентом связан.

Когда URL изменяется, этот факт отлавливает BrowserRouter и происходит повторный рендеринг. Соответственно, при повторном рендеринге у Routes есть доступ к обновленному URL, так что он проверяет вложенные в себя Route и определяет компонент, который нужно отрисовать.



# Компонент Route

Описывает маршрут

- path проп - адрес маршрута
  - Задаем шаблон маршрута
- element проп - какой компонент отображать







# Динамический маршрут

Динамический маршрут - это маршрут, в котором есть изменяющийся параметр, например:

```
www.foobar.com/notes/7
```

где 7 - id заметки и он изменяется в зависимости от того, какую заметку нужно открыть.

## Организация динамического маршрута

Работа с динамическими маршрутами строится примерно так:

* В компоненте `<Route>` через атрибут path задаем путь с изменяющимся параметром:

  ```react
  <Route path='/notes/:id' element={<Note />} />
  ```

  Изменяющийся параметр отделяем двоеточием `:`

* Организуем переходы. Как именно - не важно, можно через компонент Link, можно через хук useNavigate. Главное правильно формировать ссылки.

* Создаем компонент для динамического маршрута. В нем с помощью хука `useParams` можем извлечь значение динамического параметра из url.

  * Параметр будет называться так же, как он описан в Route. Например, если там `/notes/:id`, то и при извлечении к нему надо обращаться как `id`

    ```javascript
    const params = useParams();  // <-- Получаем параметры из url
    const id = params.id;
    ```

    

## Пример

```react
import { BrowserRouter } from 'react-router-dom';
import { Routes, Route } from 'react-router-dom';
import { useNavigate } from 'react-router-dom';
import { useParams } from 'react-router-dom';

export default function App() {
  return (
    <BrowserRouter>
      <Routes>
        <Route path='/notes' element={<Notes />} />
        <Route path='/notes/:id' element={<Note />} />  {/* <-- Динамический маршрут */}
      </Routes>
    </BrowserRouter>
  );
}

// <-- Компонент со списком заметок
function Notes() {
  const notes = [...Array(10)].map((_, i) => { return { 
      id: i + 1, 
      short: `Заметка #${i + 1}`
    }
  });

  const navigate = useNavigate();
  const read = (id) => navigate(`/notes/${id}`);  // <-- Реализация перехода через useNavigate.

  return (
    <>
      <h1>Страница со списком заметок</h1>
      {
        notes.map(n => <div>{n.short}
            <Link to={`/notes/${n.id}`}>Читать</Link> {/* Реализация перехода через Link */}
            <button onClick={() => read(n.id)}>Читать</button>
          </div>
        )
      }
    </>
  );
}

// <-- Компонент конкретной заметки
function Note() {
  const params = useParams();  // <-- Получаем параметры из url
  // <-- Используем параметры для дальнейших действий
  return <h1>Страница заметки #{params.id}</h1>
}
```





# Вынос маршрутов из кода

Можно оформить маршруты в виде, например, массива и вынести его в отдельный файл. Так будет проще их редактировать:

```javascript
import { Glagne, About, Store } from './pages.js';

export const routes = [
  { 
    path: '/', 
    element: <Glagne /> 
  },
  { 
    path: '/about', 
    element: <About /> 
  },
  { 
    path: '/store',
    element: <Store />
  },
];

```

Все страницы для простоты оформлены в единственном файле `pages.js`:

```react
export function Glagne() {
  return <h1>Это стартовая страница приложения</h1>
}

export function About() {
  return <h1>Здесь можно почитать о приложении</h1>
}

export function Store() {
  return <h1>Ознакомьтесь с нашими услугами</h1>
}
```

Компонент приложения:

```react
import { BrowserRouter } from 'react-router-dom';
import { Routes, Route } from 'react-router-dom';
import { Link } from 'react-router-dom';
import { routes } from './routes';

export default function App() {
  return (
    <BrowserRouter>
      <Menu />
      <Routes>
        {/* Отрисовываем маршруты на основе массива */}
        { routes.map(r => <Route path={r.path} element={r.element} />) }
      </Routes>
    </BrowserRouter>
  );
}

// <-- Компонент навигационной панели
function Menu() {
  return (
    <div style={{ display: 'flex', columnGap: '5rem' }}>
      <Link to='/'>На главную</Link>
      <Link to='/about'>О приложении</Link>
      <Link to='/store'>Магазин</Link>
    </div>
  )
}
```



# Публичные и приватные маршруты

Тут скорее просто заглушка для будущих исследований, потому что описанный способ выглядит так себе.

```react
import { BrowserRouter } from 'react-router-dom';
import { Routes, Route } from 'react-router-dom';
import { Link } from 'react-router-dom';

export default function App() {
  const isAuth = false;
  const printRoutes = isAuth ? routes : routes.filter(r => r.access === 'public');
  return (
    <BrowserRouter>
      <Menu />
      <Routes>
        { printRoutes.map(r => <Route path={r.path} element={r.element} />) }
      </Routes>
    </BrowserRouter>
  );
}

// <-- Коллекция маршрутов
export const routes = [
  { 
    path: '/', 
    element: <Glagne />,
    access: 'public'
  },
  { 
    path: '/about', 
    element: <About />,
    access: 'public'
  },
  { 
    path: '/store',
    element: <Store />,
    access: 'private'
  },
];


// <-- Компонент навигационной панели
function Menu() {
  return (
    <div style={{ display: 'flex', columnGap: '5rem' }}>
      <Link to='/'>На главную</Link>
      <Link to='/about'>О приложении</Link>
      <Link to='/store'>Магазин</Link>
    </div>
  )
}

// <-- Компоненты страниц
export function Glagne() {
  return <h1>Это стартовая страница приложения</h1>
}

export function About() {
  return <h1>Здесь можно почитать о приложении</h1>
}

export function Store() {
  return <h1>Ознакомьтесь с нашими услугами</h1>
}
```

